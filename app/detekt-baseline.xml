<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ArgumentListWrapping:AppDrawer.kt$( icon = Icons.AutoMirrored.Filled.ExitToApp, text = stringResource(R.string.menu_logout), onClick = { onCloseDrawer() onLogout() })</ID>
    <ID>ArgumentListWrapping:AppDrawer.kt$( icon = Icons.AutoMirrored.Filled.List, text = stringResource(R.string.menu_licenses), onClick = { onCloseDrawer() onNavigateToLicense() })</ID>
    <ID>ArgumentListWrapping:AppDrawer.kt$( icon = Icons.Default.Info, text = stringResource(R.string.menu_app_info), onClick = { onCloseDrawer() onNavigateToAppInfo() })</ID>
    <ID>ArgumentListWrapping:AppDrawer.kt$( icon = Icons.Default.Settings, text = stringResource(R.string.menu_settings), onClick = { onCloseDrawer() onNavigateToSettings() })</ID>
    <ID>ArgumentListWrapping:AppDrawer.kt$( onNavigateToSettings = {}, onNavigateToLicense = {}, onNavigateToAppInfo = {}, onLogout = {}, onCloseDrawer = {})</ID>
    <ID>ArgumentListWrapping:AppDrawer.kt$( text = stringResource(R.string.app_name), style = MaterialTheme.typography.titleLarge, modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp))</ID>
    <ID>ArgumentListWrapping:AppInfoScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>ArgumentListWrapping:AppInfoScreen.kt$( text = stringResource(R.string.app_name), style = MaterialTheme.typography.headlineMedium)</ID>
    <ID>ArgumentListWrapping:AppInfoScreen.kt$( text = stringResource(R.string.label_version), style = MaterialTheme.typography.titleMedium)</ID>
    <ID>ArgumentListWrapping:AppInfoScreen.kt$( title = { Text(stringResource(R.string.title_app_info)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>ArgumentListWrapping:AppInfoScreen.kt$( topBar = { TopAppBar( title = { Text(stringResource(R.string.title_app_info)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } }) })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( bookmark = bookmark, onClick = { clickedBookmark -&gt; viewModel?.let { vm -&gt; if (clickedBookmark.urls.size == 1) { try { uriHandler.openUri(clickedBookmark.urls.first()) } catch (e: Exception) { vm.setUrlOpenError(e.message ?: urlOpenErrorText) } } else { vm.onBookmarkCardClicked(clickedBookmark) } } })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( containerColor = if (hasUrls) MaterialTheme.colorScheme.surface else MaterialTheme.colorScheme.surfaceVariant)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( isRefreshing = uiState.isLoading, onRefresh = onRefresh, modifier = Modifier.padding(paddingValues).fillMaxSize())</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( kind = 39701, content = "Fetched title from OG metadata.", author = "efgh5678efgh5678", createdAt = System.currentTimeMillis() / 1000 - 3600, tags = emptyList())</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( kind = 39701, content = "This is a sample bookmark description from the event content.", author = "abcd1234abcd1234", createdAt = System.currentTimeMillis() / 1000, tags = emptyList())</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( modifier = Modifier.fillMaxSize(), contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp))</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( modifier = Modifier.fillMaxWidth() .then(if (hasUrls) Modifier.clickable { onClick(bookmark) } else Modifier), elevation = CardDefaults.cardElevation(defaultElevation = 2.dp), colors = CardDefaults.cardColors( containerColor = if (hasUrls) MaterialTheme.colorScheme.surface else MaterialTheme.colorScheme.surfaceVariant))</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( selected = uiState.selectedTab == BookmarkFilterMode.Global, onClick = { onTabSelected(BookmarkFilterMode.Global) }, text = { Text(stringResource(R.string.tab_global)) })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( selected = uiState.selectedTab == BookmarkFilterMode.Local, onClick = { onTabSelected(BookmarkFilterMode.Local) }, text = { Text(stringResource(R.string.tab_local)) })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( selectedTabIndex = if (uiState.selectedTab == BookmarkFilterMode.Local) 0 else 1)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = "(Title from OG metadata)", style = MaterialTheme.typography.labelSmall, color = MaterialTheme.colorScheme.tertiary)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = "URLs (${bookmark.urls.size})", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.tertiary)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = description, style = MaterialTheme.typography.bodyMedium, maxLines = 3, overflow = TextOverflow.Ellipsis)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = formatTimestamp(event.createdAt), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = stringResource(R.string.message_no_bookmarks), style = MaterialTheme.typography.bodyLarge)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = title, style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.primary, maxLines = 2, overflow = TextOverflow.Ellipsis)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = uiState.error, style = MaterialTheme.typography.bodyLarge, color = MaterialTheme.colorScheme.error)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( text = url, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary, modifier = Modifier.padding(vertical = 2.dp), maxLines = 1, overflow = TextOverflow.Ellipsis)</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( title = { Text(stringResource(R.string.title_bookmarks)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( topBar = { Column { TopAppBar( title = { Text(stringResource(R.string.title_bookmarks)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } }) PrimaryTabRow( selectedTabIndex = if (uiState.selectedTab == BookmarkFilterMode.Local) 0 else 1) { Tab( selected = uiState.selectedTab == BookmarkFilterMode.Local, onClick = { onTabSelected(BookmarkFilterMode.Local) }, text = { Text(stringResource(R.string.tab_local)) }) Tab( selected = uiState.selectedTab == BookmarkFilterMode.Global, onClick = { onTabSelected(BookmarkFilterMode.Global) }, text = { Text(stringResource(R.string.tab_global)) }) } } }, floatingActionButton = { FloatingActionButton(onClick = onAddBookmark) { Icon(imageVector = Icons.Filled.Add, contentDescription = "Add bookmark") } })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( type = "event", eventId = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", title = "Example Article Title", url = "https://example.com/article", urls = listOf("https://example.com/article", "https://example.com/related"), titleSource = "tag", event = BookmarkedEvent( kind = 39701, content = "This is a sample bookmark description from the event content.", author = "abcd1234abcd1234", createdAt = System.currentTimeMillis() / 1000, tags = emptyList()))</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( type = "event", eventId = "abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890", title = "Another Bookmark", url = "https://example.com/another", urls = listOf("https://example.com/another"), titleSource = "metadata", event = BookmarkedEvent( kind = 39701, content = "Fetched title from OG metadata.", author = "efgh5678efgh5678", createdAt = System.currentTimeMillis() / 1000 - 3600, tags = emptyList()))</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( uiState = BookmarkUiState(isLoading = false, bookmarks = emptyList()), onRefresh = {}, onLoad = {})</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( uiState = BookmarkUiState(isLoading = false, bookmarks = sampleBookmarks), onRefresh = {}, onLoad = {})</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( uiState.bookmarks, key = { bookmark -&gt; "${bookmark.type}:${bookmark.eventId ?: bookmark.hashCode()}" })</ID>
    <ID>ArgumentListWrapping:BookmarkScreen.kt$( urls = bookmark.urls, onUrlSelected = { url -&gt; vm.dismissUrlDialog() try { uriHandler.openUri(url) } catch (e: Exception) { vm.setUrlOpenError(e.message ?: urlOpenErrorText) } }, onDismiss = { vm.dismissUrlDialog() })</ID>
    <ID>ArgumentListWrapping:BookmarkViewModel.kt$BookmarkViewModel$( isLoading = false, allBookmarks = allItems, userHexPubkey = userHexPubkey, error = null)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModel.kt$BookmarkViewModel$( onSuccess = { bookmarkList -&gt; val allItems = bookmarkList?.items ?: emptyList() _uiState.update { state -&gt; val updatedState = state.copy( isLoading = false, allBookmarks = allItems, userHexPubkey = userHexPubkey, error = null) updatedState.copy(bookmarks = filterBookmarks(updatedState)) } }, onFailure = { e -&gt; _uiState.value = _uiState.value.copy( isLoading = false, error = e.message ?: "Failed to load bookmarks") })</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "All bookmarks should have matching author", state.bookmarks.all { it.event?.author == "author1" })</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "https://example.com/1", "https://example.com/2", "https://example.com/3")</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be null after dismissing", state.selectedBookmarkForUrlDialog)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be set for multiple URLs", state.selectedBookmarkForUrlDialog)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be the clicked bookmark", bookmarkWithMultipleUrls, state.selectedBookmarkForUrlDialog)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedTab should be Global after selecting", BookmarkFilterMode.Global, state.selectedTab)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( BookmarkItem( type = "event", eventId = "id1", title = "Bookmark 1", urls = listOf("https://example.com/1")))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( allBookmarks = testBookmarks, userHexPubkey = "author1", selectedTab = BookmarkFilterMode.Global)</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( createTestBookmarkItem("id1", "author1"), createTestBookmarkItem("id2", "author2"), createTestBookmarkItem("id3", "author1"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( kind = 39701, content = "content", author = author, createdAt = System.currentTimeMillis() / 1000, tags = emptyList())</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "concurrent-test", title = "Concurrent Test", urls = listOf("https://example.com/1", "https://example.com/2"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "id1", title = "Bookmark 1", urls = listOf("https://example.com/1"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "test789", title = "Multiple URLs Bookmark", urls = listOf( "https://example.com/1", "https://example.com/2", "https://example.com/3"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "test999", title = "Test Dismiss", urls = listOf("https://example.com/a", "https://example.com/b"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "workflow-test", title = "Workflow Test", urls = listOf("https://example.com/1", "https://example.com/2"))</ID>
    <ID>ArgumentListWrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = eventId, title = "Test $eventId", urls = listOf("https://example.com/$eventId"), event = io.github.omochice.pinosu.domain.model.BookmarkedEvent( kind = 39701, content = "content", author = author, createdAt = System.currentTimeMillis() / 1000, tags = emptyList()))</ID>
    <ID>ArgumentListWrapping:DrawerMenuItem.kt$( imageVector = icon, contentDescription = text, tint = MaterialTheme.colorScheme.primary)</ID>
    <ID>ArgumentListWrapping:DrawerMenuItem.kt$( modifier = modifier .fillMaxWidth() .clickable(onClick = onClick) .padding(horizontal = 16.dp, vertical = 12.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>ArgumentListWrapping:ErrorDialog.kt$( onDismissRequest = onDismiss, title = { Text(stringResource(R.string.dialog_title_error)) }, text = { Text(message) }, confirmButton = { Button(onClick = onDismiss) { Text(stringResource(R.string.button_ok)) } })</ID>
    <ID>ArgumentListWrapping:ErrorTypesTest.kt$ErrorTypesTest$( LoginError.Nip55SignerNotInstalled, LoginError.UserRejected, LoginError.Timeout, LoginError.NetworkError("test"), LoginError.UnknownError(RuntimeException()))</ID>
    <ID>ArgumentListWrapping:ErrorTypesTest.kt$ErrorTypesTest$( Nip55Error.NotInstalled, Nip55Error.UserRejected, Nip55Error.Timeout, Nip55Error.InvalidResponse("test"), Nip55Error.IntentResolutionError("test"))</ID>
    <ID>ArgumentListWrapping:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$( IllegalArgumentException("Invalid npub format: must be Bech32-encoded (npub1...)"))</ID>
    <ID>ArgumentListWrapping:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$( "Should propagate original error message", "Network error", result.exceptionOrNull()?.message)</ID>
    <ID>ArgumentListWrapping:LicenseScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>ArgumentListWrapping:LicenseScreen.kt$( title = { Text(stringResource(R.string.title_licenses)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>ArgumentListWrapping:LicenseScreen.kt$( topBar = { TopAppBar( title = { Text(stringResource(R.string.title_licenses)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } }) })</ID>
    <ID>ArgumentListWrapping:LocalAuthDataSource.kt$LocalAuthDataSource.Companion$( context, "pinosu_auth_prefs", masterKey, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM)</ID>
    <ID>ArgumentListWrapping:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$( RelayConfig(url = "wss://relay1.example.com", read = true, write = true), RelayConfig(url = "wss://relay2.example.com", read = true, write = false))</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( errorMessage = "Login process timed out. Please check the NIP-55 signer app and retry.")</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center, modifier = Modifier.padding(16.dp))</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( onDismissRequest = onDismissDialog, title = { Text(stringResource(R.string.dialog_title_error)) }, text = { Text(uiState.errorMessage) }, confirmButton = { if (isTimeoutError) { Button(onClick = onRetry) { Text(stringResource(R.string.button_retry)) } } else { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_ok)) } } }, dismissButton = { if (isTimeoutError) { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_cancel)) } } else { null } })</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( onDismissRequest = onDismissDialog, title = { Text(stringResource(R.string.dialog_title_nip55_signer_required)) }, text = { Text(stringResource(R.string.dialog_message_nip55_signer_required)) }, confirmButton = { Button(onClick = onInstallNip55Signer) { Text(stringResource(R.string.button_install)) } }, dismissButton = { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_close)) } })</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( text = stringResource(R.string.message_loading), style = MaterialTheme.typography.bodyMedium)</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( text = stringResource(R.string.message_login_success), style = MaterialTheme.typography.headlineSmall, color = MaterialTheme.colorScheme.primary)</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( uiState = LoginUiState( errorMessage = "Login process timed out. Please check the NIP-55 signer app and retry."), onLoginButtonClick = {})</ID>
    <ID>ArgumentListWrapping:LoginScreen.kt$( uiState = LoginUiState(errorMessage = "Login was cancelled. Please try again."), onLoginButtonClick = {})</ID>
    <ID>ArgumentListWrapping:LoginViewModel.kt$LoginViewModel$( TAG, "Failed to fetch NIP-65 relay list: ${relayResult.exceptionOrNull()?.message}")</ID>
    <ID>ArgumentListWrapping:LoginViewModelTest.kt$LoginViewModelTest$( "errorMessage should be null (relay fetch failure is logged, not shown)", state.errorMessage)</ID>
    <ID>ArgumentListWrapping:LoginViewModelTest.kt$LoginViewModelTest$( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true)</ID>
    <ID>ArgumentListWrapping:LoginViewModelTest.kt$LoginViewModelTest$( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase)</ID>
    <ID>ArgumentListWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest$( "Exception should be LogoutError.StorageError", exception is LogoutError.StorageError)</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( contract = ActivityResultContracts.StartActivityForResult())</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( enterTransition = { EnterTransition.None }, exitTransition = { ExitTransition.None }, popEnterTransition = { EnterTransition.None }, popExitTransition = { ExitTransition.None })</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( enterTransition = { defaultEnterTransition }, exitTransition = { defaultExitTransition }, popEnterTransition = { defaultPopEnterTransition }, popExitTransition = { defaultPopExitTransition })</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( uiState = bookmarkUiState, onRefresh = { bookmarkViewModel.refresh() }, onLoad = { bookmarkViewModel.loadBookmarks() }, onOpenDrawer = { scope.launch { drawerState.open() } }, onTabSelected = { tab -&gt; bookmarkViewModel.selectTab(tab) }, onAddBookmark = { navController.navigate(PostBookmark) }, viewModel = bookmarkViewModel)</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( uiState = loginUiState, onLoginButtonClick = { viewModel.onLoginButtonClicked() if (nip55SignerClient.checkNip55SignerInstalled()) { val intent = nip55SignerClient.createPublicKeyIntent() nip55Launcher.launch(intent) } }, onDismissDialog = { viewModel.dismissError() }, onInstallNip55Signer = { // TODO: Implement Play Store link }, onRetry = { viewModel.onRetryLogin() if (nip55SignerClient.checkNip55SignerInstalled()) { val intent = nip55SignerClient.createPublicKeyIntent() nip55Launcher.launch(intent) } }, onLoginSuccess = { navController.navigate(Bookmark) { popUpTo&lt;Login&gt; { inclusive = true } } viewModel.dismissError() })</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( uiState = mainUiState, onLogout = { viewModel.onLogoutButtonClicked() }, onOpenDrawer = { scope.launch { drawerState.open() } }, onNavigateToLogin = {})</ID>
    <ID>ArgumentListWrapping:MainActivity.kt$( uiState = postBookmarkUiState, onUrlChange = { postBookmarkViewModel.updateUrl(it) }, onTitleChange = { postBookmarkViewModel.updateTitle(it) }, onCategoriesChange = { postBookmarkViewModel.updateCategories(it) }, onCommentChange = { postBookmarkViewModel.updateComment(it) }, onPostClick = { postBookmarkViewModel.prepareSignEventIntent { intent -&gt; intent?.let { signEventLauncher.launch(it) } } }, onNavigateBack = { navController.navigateUp() }, onDismissError = { postBookmarkViewModel.dismissError() })</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( modifier = Modifier.padding(paddingValues).fillMaxSize(), color = MaterialTheme.colorScheme.background)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( text = formatPubkey(uiState.userPubkey), style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( text = stringResource(R.string.message_logging_out), style = MaterialTheme.typography.bodyLarge, textAlign = TextAlign.Center)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( text = stringResource(R.string.text_logged_in), style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( text = stringResource(R.string.text_not_logged_in), style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( title = { Text(stringResource(R.string.app_name)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } })</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( topBar = { TopAppBar( title = { Text(stringResource(R.string.app_name)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } }) })</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( userPubkey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", isLoggingOut = false)</ID>
    <ID>ArgumentListWrapping:MainScreen.kt$( userPubkey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", isLoggingOut = true)</ID>
    <ID>ArgumentListWrapping:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$( "Cause should be StorageError", unknownError.throwable is StorageError.WriteError)</ID>
    <ID>ArgumentListWrapping:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$( "Exception should be LoginError.Nip55SignerNotInstalled", exception is LoginError.Nip55SignerNotInstalled)</ID>
    <ID>ArgumentListWrapping:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$( "Exception should be LoginError.UnknownError", exception is LoginError.UnknownError)</ID>
    <ID>ArgumentListWrapping:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$( "Exception should be LogoutError.StorageError", exception is LogoutError.StorageError)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClient.kt$Nip55SignerClient$( NIP55_SIGNER_PACKAGE_NAME, PackageManager.GET_ACTIVITIES)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClient.kt$Nip55SignerClient$( Nip55Error.InvalidResponse("Invalid pubkey format: must be Bech32-encoded (npub1...)"))</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse"))</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Error should be UserRejected", error is Nip55Error.UserRejected || error.toString().contains("UserRejected"))</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Intent action should be ACTION_VIEW", android.content.Intent.ACTION_VIEW, intent.action)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Intent should have SINGLE_TOP and CLEAR_TOP flags", (intent.flags and expectedFlags) == expectedFlags)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Package should be NIP-55 signer package name", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, intent.`package`)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "PackageName should be NIP-55 signer package", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, response?.packageName)</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Type extra should be get_public_key", Nip55SignerClient.TYPE_GET_PUBLIC_KEY, intent.getStringExtra("type"))</ID>
    <ID>ArgumentListWrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "URI scheme should be nostrsigner", Nip55SignerClient.NOSTRSIGNER_SCHEME, intent.data?.scheme)</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( "URL should be the valid wss one", "wss://valid-relay.example.com", result.first().url)</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( id = "test-event-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 10002, tags = tags, content = "")</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( id = "test-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 1, // Wrong kind, should be 10002 tags = listOf(listOf("r", "wss://relay.example.com")), content = "")</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf( listOf("r"), // Missing URL listOf("r", "wss://valid-relay.example.com")))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf( listOf("r", "http://not-websocket.example.com"), listOf("r", "wss://valid-relay.example.com")))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf( listOf("r", "wss://relay.example.com"), listOf("p", "pubkey123"), listOf("e", "eventid456")))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf( listOf("r", "wss://relay1.example.com"), listOf("r", "wss://relay2.example.com", "read"), listOf("r", "wss://relay3.example.com", "write")))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r"), // Missing URL listOf("r", "wss://valid-relay.example.com"))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "http://not-websocket.example.com"), listOf("r", "wss://valid-relay.example.com"))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "wss://relay.example.com"), listOf("p", "pubkey123"), listOf("e", "eventid456"))</ID>
    <ID>ArgumentListWrapping:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "wss://relay1.example.com"), listOf("r", "wss://relay2.example.com", "read"), listOf("r", "wss://relay3.example.com", "write"))</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$( IllegalArgumentException("Invalid hex pubkey: must be 64 hex characters"))</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( "Exception message should be preserved", result.exceptionOrNull()?.message?.contains("Network error") == true)</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( "Should use relay from newer event", "wss://new-relay.example.com", relays.first().url)</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( any(), match { it.contains("\"kinds\":[10002]") &amp;&amp; it.contains("\"authors\":[\"$hexPubkey\"]") }, any())</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( hexPubkey, listOf(listOf("r", "wss://new-relay.example.com")), createdAt = 2000L)</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( hexPubkey, listOf(listOf("r", "wss://old-relay.example.com")), createdAt = 1000L)</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( id = "test-event-id-${createdAt}", pubkey = pubkey, createdAt = createdAt, kind = 10002, tags = tags, content = "")</ID>
    <ID>ArgumentListWrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( match { relays -&gt; relays.any { it.url == "wss://yabu.me" } }, any(), any())</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( modifier = Modifier.align(Alignment.Center).semantics { contentDescription = "読み込み中" })</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( modifier = Modifier.fillMaxSize() .padding(paddingValues) .padding(horizontal = 16.dp) .verticalScroll(rememberScrollState()))</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( onClick = onPostClick, modifier = Modifier.fillMaxWidth(), enabled = uiState.url.isNotBlank())</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( text = "URL", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( text = "https://", style = MaterialTheme.typography.bodyLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( title = { Text("ブックマークを追加") }, navigationIcon = { IconButton(onClick = onNavigateBack) { Icon(imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "戻る") } })</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( topBar = { TopAppBar( title = { Text("ブックマークを追加") }, navigationIcon = { IconButton(onClick = onNavigateBack) { Icon(imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "戻る") } }) })</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState( url = "example.com/article", title = "Sample Article", categories = "tech, kotlin", comment = "This is a great article about Kotlin"), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState(), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState(isSubmitting = true), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( url = "example.com/article", title = "Sample Article", categories = "tech, kotlin", comment = "This is a great article about Kotlin")</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( value = uiState.categories, onValueChange = onCategoriesChange, modifier = Modifier.fillMaxWidth(), label = { Text("カテゴリ") }, singleLine = true, placeholder = { Text("tech, programming, kotlin") }, supportingText = { Text("カンマ区切りで複数入力できます") })</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( value = uiState.comment, onValueChange = onCommentChange, modifier = Modifier.fillMaxWidth().height(120.dp), label = { Text("コメント") }, placeholder = { Text("ブックマークについてのメモ") }, maxLines = 5)</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( value = uiState.title, onValueChange = onTitleChange, modifier = Modifier.fillMaxWidth(), label = { Text("タイトル") }, singleLine = true, placeholder = { Text("ブックマークのタイトル") })</ID>
    <ID>ArgumentListWrapping:PostBookmarkScreen.kt$( value = uiState.url, onValueChange = onUrlChange, modifier = Modifier.weight(1f), singleLine = true, placeholder = { Text("example.com/path") })</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$( bookmarkRepository.createBookmarkEvent( hexPubkey = hexPubkey, url = url, title = title, categories = categories, comment = comment))</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$( hexPubkey = hexPubkey, url = url, title = title, categories = categories, comment = comment)</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( eventId = "abc123", successfulRelays = listOf("wss://relay1.example.com"), failedRelays = emptyList())</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( hexPubkey = any(), url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article")</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( pubkey = hexPubkey, createdAt = 1234567890L, kind = 39701, tags = listOf(listOf("r", "https://example.com/article")), content = "Great article")</ID>
    <ID>ArgumentListWrapping:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article")</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModel.kt$PostBookmarkViewModel$( isSubmitting = false, errorMessage = error.message ?: "ブックマークの投稿に失敗しました")</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModel.kt$PostBookmarkViewModel$( url = state.url, title = state.title, categories = categories, comment = state.comment)</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( any(), any(), match { it == listOf("tech", "kotlin", "android") }, any())</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = emptyList(), content = "")</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "Test comment")</ID>
    <ID>ArgumentListWrapping:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "comment")</ID>
    <ID>ArgumentListWrapping:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true)</ID>
    <ID>ArgumentListWrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$( BookmarkList( pubkey = event.pubkey, items = itemsWithEvents, createdAt = event.createdAt, encryptedContent = encryptedContent))</ID>
    <ID>ArgumentListWrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$( kind = event.kind, content = event.content, author = event.pubkey, createdAt = event.createdAt, tags = event.tags)</ID>
    <ID>ArgumentListWrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$( pubkey = event.pubkey, items = itemsWithEvents, createdAt = event.createdAt, encryptedContent = encryptedContent)</ID>
    <ID>ArgumentListWrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$( pubkey = hexPubkey, createdAt = System.currentTimeMillis() / 1000, kind = KIND_BOOKMARK_LIST, tags = tags, content = comment)</ID>
    <ID>ArgumentListWrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$( type = "event", eventId = event.id, url = urls.first(), urls = urls, title = title, titleSource = titleSource, event = BookmarkedEvent( kind = event.kind, content = event.content, author = event.pubkey, createdAt = event.createdAt, tags = event.tags))</ID>
    <ID>ArgumentListWrapping:RelayPool.kt$RelayPoolImpl$( "Failed to publish to any relay: ${failed.joinToString { "${it.first}: ${it.second}" }}")</ID>
    <ID>ArgumentListWrapping:RelayPool.kt$RelayPoolImpl$( Exception( "Failed to publish to any relay: ${failed.joinToString { "${it.first}: ${it.second}" }}"))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Error should mention failed to publish", result.exceptionOrNull()?.message?.contains("Failed to publish") == true)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Error should mention invalid JSON", result.exceptionOrNull()?.message?.contains("Invalid JSON") == true)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Error should mention no write-enabled relays", result.exceptionOrNull()?.message?.contains("No write-enabled relays") == true)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Failed relay should be rejecting", publishResult?.failedRelays?.any { it.first == "wss://rejecting.example.com" } == true)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Should have 1 successful relay", listOf("wss://relay.example.com"), publishResult?.successfulRelays)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Should only have write-enabled relay in success list", listOf("wss://write-relay.example.com"), publishResult?.successfulRelays)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( "Successful relay should be accepting", publishResult?.successfulRelays?.contains("wss://accepting.example.com") == true)</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://accepting.example.com", write = true), RelayConfig(url = "wss://rejecting.example.com", write = true))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://failing.example.com"), RelayConfig(url = "wss://working.example.com"))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://read-only-relay.example.com", write = false), RelayConfig(url = "wss://write-relay.example.com", write = true))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://relay1.example.com"), RelayConfig(url = "wss://relay2.example.com"))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://relay1.example.com", write = false), RelayConfig(url = "wss://relay2.example.com", write = false))</ID>
    <ID>ArgumentListWrapping:RelayPoolTest.kt$RelayPoolTest$( id = id, pubkey = pubkey, createdAt = System.currentTimeMillis() / 1000, kind = 39701, tags = listOf(listOf("r", "https://example.com")), content = "")</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( mode = mode, selected = uiState.themeMode == mode, onClick = { onThemeModeSelected(mode) })</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( modifier = Modifier.fillMaxWidth().clickable(onClick = onClick).padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( text = stringResource( when (mode) { ThemeMode.Light -&gt; R.string.theme_light ThemeMode.Dark -&gt; R.string.theme_dark ThemeMode.System -&gt; R.string.theme_system }), style = MaterialTheme.typography.bodyLarge)</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( text = stringResource(R.string.label_theme), style = MaterialTheme.typography.titleMedium)</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( title = { Text(stringResource(R.string.title_settings)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( topBar = { TopAppBar( title = { Text(stringResource(R.string.title_settings)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } }) })</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( uiState = SettingsUiState(themeMode = ThemeMode.System), onThemeModeSelected = {}, onNavigateUp = {})</ID>
    <ID>ArgumentListWrapping:SettingsScreen.kt$( when (mode) { ThemeMode.Light -&gt; R.string.theme_light ThemeMode.Dark -&gt; R.string.theme_dark ThemeMode.System -&gt; R.string.theme_system })</ID>
    <ID>ArgumentListWrapping:UrlSelectionDialog.kt$( modifier = Modifier.fillMaxWidth() .clickable { selectedUrl = url } .padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>ArgumentListWrapping:UrlSelectionDialog.kt$( onDismissRequest = onDismiss, title = { Text(stringResource(R.string.dialog_title_select_url)) }, text = { Column(modifier = Modifier.fillMaxWidth().verticalScroll(rememberScrollState())) { urls.forEach { url -&gt; Row( modifier = Modifier.fillMaxWidth() .clickable { selectedUrl = url } .padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) { RadioButton(selected = selectedUrl == url, onClick = { selectedUrl = url }) Text( text = url, modifier = Modifier.padding(start = 8.dp), style = MaterialTheme.typography.bodyMedium, maxLines = 2, overflow = TextOverflow.Ellipsis) } } } }, confirmButton = { Button(onClick = { selectedUrl?.let(onUrlSelected) }, enabled = selectedUrl != null) { Text(stringResource(R.string.button_open)) } }, dismissButton = { TextButton(onClick = onDismiss) { Text(stringResource(R.string.button_cancel)) } })</ID>
    <ID>ArgumentListWrapping:UrlSelectionDialog.kt$( text = url, modifier = Modifier.padding(start = 8.dp), style = MaterialTheme.typography.bodyMedium, maxLines = 2, overflow = TextOverflow.Ellipsis)</ID>
    <ID>BracesOnIfStatements:BookmarkScreen.kt$if</ID>
    <ID>BracesOnWhenStatements:BookmarkViewModel.kt$BookmarkViewModel$when</ID>
    <ID>ClassOrdering:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$override suspend fun invoke(npubPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt;</ID>
    <ID>ClassOrdering:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$Companion</ID>
    <ID>ClassOrdering:LocalAuthDataSource.kt$LocalAuthDataSource$Companion</ID>
    <ID>ClassOrdering:LoginViewModel.kt$LoginViewModel$Companion</ID>
    <ID>ClassOrdering:Nip65EventParser.kt$Nip65EventParserImpl$Companion</ID>
    <ID>ClassOrdering:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$Companion</ID>
    <ID>ClassOrdering:RelayBookmarkRepository.kt$RelayBookmarkRepository$Companion</ID>
    <ID>ClassOrdering:RelayPool.kt$RelayPoolImpl$Companion</ID>
    <ID>ClassOrdering:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$Companion</ID>
    <ID>CognitiveComplexMethod:BookmarkScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun BookmarkScreen( uiState: BookmarkUiState, onRefresh: () -&gt; Unit, onLoad: () -&gt; Unit, onOpenDrawer: () -&gt; Unit = {}, onTabSelected: (BookmarkFilterMode) -&gt; Unit = {}, onAddBookmark: () -&gt; Unit = {}, viewModel: BookmarkViewModel? = null, )</ID>
    <ID>CognitiveComplexMethod:LoginScreen.kt$@Composable fun LoginScreen( uiState: LoginUiState, onLoginButtonClick: () -&gt; Unit, onDismissDialog: () -&gt; Unit = {}, onInstallNip55Signer: () -&gt; Unit = {}, onRetry: () -&gt; Unit = {}, onLoginSuccess: () -&gt; Unit = {} )</ID>
    <ID>CognitiveComplexMethod:RelayPool.kt$RelayPoolImpl$private suspend fun publishToRelay( relayUrl: String, signedEventJson: String ): Pair&lt;String, String&gt;</ID>
    <ID>CyclomaticComplexMethod:BookmarkScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun BookmarkScreen( uiState: BookmarkUiState, onRefresh: () -&gt; Unit, onLoad: () -&gt; Unit, onOpenDrawer: () -&gt; Unit = {}, onTabSelected: (BookmarkFilterMode) -&gt; Unit = {}, onAddBookmark: () -&gt; Unit = {}, viewModel: BookmarkViewModel? = null, )</ID>
    <ID>CyclomaticComplexMethod:RelayBookmarkRepository.kt$RelayBookmarkRepository$override suspend fun getBookmarkList(pubkey: String): Result&lt;BookmarkList?&gt;</ID>
    <ID>ExpressionBodySyntax:Bech32.kt$Bech32$return decodePublicKeyAsHexOrNull(npub)</ID>
    <ID>ExpressionBodySyntax:GetBookmarkListUseCaseImpl.kt$GetBookmarkListUseCaseImpl$return bookmarkRepository.getBookmarkList(pubkey)</ID>
    <ID>ExpressionBodySyntax:Nip55AuthRepository.kt$Nip55AuthRepository$return localAuthDataSource.getUser()</ID>
    <ID>ExpressionBodySyntax:Nip55AuthRepository.kt$Nip55AuthRepository$return nip55SignerClient.checkNip55SignerInstalled()</ID>
    <ID>ExpressionBodySyntax:Nip55GetLoginStateUseCase.kt$Nip55GetLoginStateUseCase$return authRepository.getLoginState()</ID>
    <ID>ExpressionBodySyntax:Nip55LoginUseCase.kt$Nip55LoginUseCase$return authRepository.checkNip55SignerInstalled()</ID>
    <ID>ExpressionBodySyntax:Nip55LogoutUseCase.kt$Nip55LogoutUseCase$return authRepository.logout()</ID>
    <ID>ExpressionBodySyntax:Nip65EventParser.kt$Nip65EventParserImpl$return url.startsWith("wss://") || url.startsWith("ws://")</ID>
    <ID>ExpressionBodySyntax:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$return pubkey.length == HEX_PUBKEY_LENGTH &amp;&amp; pubkey.all { it in HEX_CHARS }</ID>
    <ID>ExpressionBodySyntax:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$return bookmarkRepository.publishBookmark(signedEventJson)</ID>
    <ID>ExpressionBodySyntax:User.kt$return this.startsWith("npub1")</ID>
    <ID>FunctionMaxLength:AuthEventTest.kt$AuthEventTest$@Test fun `AuthEvent sealed class allows exhaustive when`()</ID>
    <ID>FunctionMaxLength:AuthEventTest.kt$AuthEventTest$@Test fun `UserLoggedIn events with different users are not equal`()</ID>
    <ID>FunctionMaxLength:AuthEventTest.kt$AuthEventTest$@Test fun `UserLoggedIn events with same user are equal`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `Global tab should show all bookmarks from allBookmarks`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `Local tab should filter bookmarks by userHexPubkey`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `Local tab with null userHexPubkey should show empty list`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `dismissErrorDialog should clear urlOpenError`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `dismissUrlDialog should clear selectedBookmarkForUrlDialog`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `error dialog workflow should work correctly`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `initial BookmarkUiState should have default values`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `loadBookmarks should set error on failure`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `loadBookmarks should set error when not logged in`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `loadBookmarks should set isLoading to true initially`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `loadBookmarks should store bookmarks in allBookmarks`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `multiple URL dialog workflow should work correctly`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `onBookmarkCardClicked with multiple URLs should set selectedBookmarkForUrlDialog`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `refresh should call loadBookmarks`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `selectTab to Global should update selectedTab`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `selectTab with same tab should not trigger state update`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `setUrlOpenError should set error message`()</ID>
    <ID>FunctionMaxLength:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `state should handle concurrent dialog states independently`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `LoginError sealed class allows exhaustive when`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `LogoutError sealed class allows exhaustive when`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `Nip55Error sealed class allows exhaustive when`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `StorageError sealed class allows exhaustive when`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create LoginError NetworkError with message`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create LoginError Nip55SignerNotInstalled`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create LoginError UnknownError with throwable`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create LoginError UserRejected`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create LogoutError StorageError with message`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create Nip55Error IntentResolutionError with message`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create Nip55Error InvalidResponse with message`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create Nip55Error NotInstalled`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create Nip55Error UserRejected`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create StorageError ReadError with message`()</ID>
    <ID>FunctionMaxLength:ErrorTypesTest.kt$ErrorTypesTest$@Test fun `create StorageError WriteError with message`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should fetch relay list and cache it on success`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should handle hex pubkey as npub`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should propagate fetch failure`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should return empty list when no NIP-65 event found`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should return failure for invalid npub format`()</ID>
    <ID>FunctionMaxLength:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$@Test fun `invoke should still return success when cache fails`()</ID>
    <ID>FunctionMaxLength:GetLoginStateUseCaseTest.kt$GetLoginStateUseCaseTest$@Test fun `invoke is read-only operation`()</ID>
    <ID>FunctionMaxLength:GetLoginStateUseCaseTest.kt$GetLoginStateUseCaseTest$@Test fun `invoke returns logged in user when user is logged in`()</ID>
    <ID>FunctionMaxLength:GetLoginStateUseCaseTest.kt$GetLoginStateUseCaseTest$@Test fun `invoke returns null when user is not logged in`()</ID>
    <ID>FunctionMaxLength:LocalAuthDataSource.kt$LocalAuthDataSource.Companion$private fun createEncryptedSharedPreferences(context: Context): SharedPreferences</ID>
    <ID>FunctionMaxLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$@Test fun `clearLoginState should clear relay list`()</ID>
    <ID>FunctionMaxLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$@Test fun `getRelayList when not set should return null`()</ID>
    <ID>FunctionMaxLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$@Test fun `getRelayList when saved should return relays`()</ID>
    <ID>FunctionMaxLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$@Test fun `saveAndGetRelayList round trip should preserve data`()</ID>
    <ID>FunctionMaxLength:LoginScreen.kt$@Preview(showBackground = true) @Composable fun LoginScreenNip55InstallDialogPreview()</ID>
    <ID>FunctionMaxLength:LoginScreen.kt$@Preview(showBackground = true) @Composable fun LoginScreenTimeoutDialogPreview()</ID>
    <ID>FunctionMaxLength:LoginUseCaseTest.kt$LoginUseCaseTest$@Test fun `checkNip55SignerInstalled when installed should return true`()</ID>
    <ID>FunctionMaxLength:LoginUseCaseTest.kt$LoginUseCaseTest$@Test fun `checkNip55SignerInstalled when not installed should return false`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `checkLoginState should keep mainUiState null when user is not logged in`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `checkLoginState should update mainUiState when user is logged in`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `dismissError should clear error message`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `initial LoginUiState should have default values`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `initial MainUiState should have default values`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onLoginButtonClicked should check if NIP-55 signer is installed`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onLoginButtonClicked should show install dialog when NIP-55 signer is not installed`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onLogoutButtonClicked should call logoutUseCase and update state on success`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onLogoutButtonClicked should handle logout failure gracefully`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onRetryLogin should retry login by calling onLoginButtonClicked`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should handle NetworkError`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should set error message on Timeout error`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should set error message on UserRejected error`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should set loading state during processing`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should set loginSuccess on success`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should succeed even if relay list fetch fails`()</ID>
    <ID>FunctionMaxLength:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should wait for relay list fetch before setting loginSuccess`()</ID>
    <ID>FunctionMaxLength:LogoutUseCaseTest.kt$LogoutUseCaseTest$@Test fun `invoke multiple calls should succeed (idempotency)`()</ID>
    <ID>FunctionMaxLength:LogoutUseCaseTest.kt$LogoutUseCaseTest$@Test fun `invoke on failure should return LogoutError`()</ID>
    <ID>FunctionMaxLength:LogoutUseCaseTest.kt$LogoutUseCaseTest$@Test fun `invoke on success should return success`()</ID>
    <ID>FunctionMaxLength:MainActivityTest.kt$MainActivityTest$@Test fun `when invalid data detected on startup, should show login screen`()</ID>
    <ID>FunctionMaxLength:MainActivityTest.kt$MainActivityTest$@Test fun `when logged in on startup, should show main screen`()</ID>
    <ID>FunctionMaxLength:MainActivityTest.kt$MainActivityTest$@Test fun `when not logged in on startup, should show login screen`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `checkNip55SignerInstalled when installed should return true`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `checkNip55SignerInstalled when not installed should return false`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `getLoginState when no user should return null`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `getLoginState when user exists should return user`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `logout on failure should return LogoutError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `logout on success should return success`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response on InvalidResponse should return NetworkError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response on success should save user and return success`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response on timeout should return TimeoutError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response when Nip55Signer not installed should return Nip55SignerNotInstalledError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response when Nip55Signer success but local storage fails should return UnknownError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response when user rejected should return LoginError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `saveLoginState on failure should return StorageError`()</ID>
    <ID>FunctionMaxLength:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `saveLoginState on success should return success`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `checkNip55SignerInstalled on exception should return false`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `checkNip55SignerInstalled when installed should return true`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `checkNip55SignerInstalled when not installed should return false`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `createPublicKeyIntent should have correct action`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `createPublicKeyIntent should have correct flags`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `createPublicKeyIntent should have correct package`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `createPublicKeyIntent should have correct scheme`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `createPublicKeyIntent should have correct type`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response on success should return Nip55Response`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response when result canceled should return UserRejected`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response when user rejected should return error`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response with empty result should return InvalidResponse`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response with invalid pubkey format should return InvalidResponse`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response with invalid pubkey length should return InvalidResponse`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `handleNip55Response with null intent should return InvalidResponse`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `maskPubkey result length should be correct`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `maskPubkey with different pubkey should return masked string`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `maskPubkey with empty string should return empty string`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `maskPubkey with short pubkey should return original string`()</ID>
    <ID>FunctionMaxLength:Nip55SignerClientTest.kt$Nip55SignerClientTest$@Test fun `maskPubkey with valid pubkey should return masked string`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with empty tags should return empty list`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with invalid url scheme should skip it`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with malformed r tag missing url should skip it`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with multiple relays should return all relays`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with no marker should return relay with both read and write true`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with non-r tags should ignore them`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with read marker should return relay with read true and write false`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with unknown marker should treat as both read and write`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with write marker should return relay with read false and write true`()</ID>
    <ID>FunctionMaxLength:Nip65EventParserTest.kt$Nip65EventParserTest$@Test fun `parseRelayListEvent with wrong kind should return empty list`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should handle relay pool exception gracefully`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should return empty list when no events found`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should return failure for invalid hex pubkey`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should return failure for wrong length pubkey`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should return parsed relay list on successful fetch`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should use bootstrap relay for query`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should use correct filter for kind 10002`()</ID>
    <ID>FunctionMaxLength:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$@Test fun `fetchRelayList should use most recent event when multiple events returned`()</ID>
    <ID>FunctionMaxLength:PostBookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun PostBookmarkScreenFilledPreview()</ID>
    <ID>FunctionMaxLength:PostBookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun PostBookmarkScreenLoadingPreview()</ID>
    <ID>FunctionMaxLength:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$@Test fun `createUnsignedEvent returns failure when npub format is invalid`()</ID>
    <ID>FunctionMaxLength:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$@Test fun `createUnsignedEvent returns failure when user not logged in`()</ID>
    <ID>FunctionMaxLength:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$@Test fun `createUnsignedEvent returns success with valid user`()</ID>
    <ID>FunctionMaxLength:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$@Test fun `publishSignedEvent delegates to repository`()</ID>
    <ID>FunctionMaxLength:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$@Test fun `publishSignedEvent returns failure when repository fails`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `dismissError should clear error message`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `initial state should have default values`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `prepareSignEventIntent should call useCase and create intent when URL is valid`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `prepareSignEventIntent should parse categories correctly`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `prepareSignEventIntent should set error on useCase failure`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `prepareSignEventIntent should set error when URL is blank`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `processSignedEvent should publish event on success`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `processSignedEvent should set error on publish failure`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `processSignedEvent should set error on signer failure`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `resetPostSuccess should set postSuccess to false`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateCategories should update categories`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateComment should update comment`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateTitle should update title`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateUrl should keep URL without scheme unchanged`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateUrl should strip HTTP uppercase scheme`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateUrl should strip HTTPS uppercase scheme`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateUrl should strip http scheme`()</ID>
    <ID>FunctionMaxLength:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$@Test fun `updateUrl should strip https scheme`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `error flow - when error dismissed - should clear error state`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `error flow - when network error - should show network error message`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `error flow - when timeout - should show timeout error message`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `error flow - when user rejected - should show error and allow retry`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `login flow - when NIP-55 signer not installed - should show install dialog`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `login flow - when NIP-55 signer response success - should update UI state and navigate to main`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `logout flow - when logout fails - should handle error gracefully`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `logout flow - when logout success - should clear login state`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `startup flow - when user logged in - should restore login state`()</ID>
    <ID>FunctionMaxLength:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `startup flow - when user not logged in - should keep null state`()</ID>
    <ID>FunctionMaxLength:RelayConfigTest.kt$RelayConfigTest$@Test fun `constructor with all parameters should set values correctly`()</ID>
    <ID>FunctionMaxLength:RelayConfigTest.kt$RelayConfigTest$@Test fun `constructor without optional parameters should use default values`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should filter only write-enabled relays`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should handle mixed success and failure from multiple relays`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should return failure when all relays reject`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should return failure when no write-enabled relays`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should return failure when signedEventJson is invalid JSON`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `publishEvent should return success when relay accepts`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout should continue on individual relay failure`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout should deduplicate events by ID`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout should merge events from multiple relays`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout when all relays fail should return empty list`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout with empty relay list should return empty list`()</ID>
    <ID>FunctionMaxLength:RelayPoolTest.kt$RelayPoolTest$@Test fun `subscribeWithTimeout with single relay should return events`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test fun `User equality works correctly`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test fun `Users with different pubkeys are not equal`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test fun `create User with valid hex pubkey containing numbers`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test fun `create User with valid pubkey`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with empty pubkey throws exception`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with non-hex characters throws exception`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with pubkey too long throws exception`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with pubkey too short throws exception`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with spaces throws exception`()</ID>
    <ID>FunctionMaxLength:UserTest.kt$UserTest$@Test(expected = IllegalArgumentException::class) fun `create User with uppercase characters throws exception`()</ID>
    <ID>FunctionSignature:BookmarkViewModelTest.kt$BookmarkViewModelTest$@Test fun `onBookmarkCardClicked with multiple URLs should set selectedBookmarkForUrlDialog`()</ID>
    <ID>FunctionSignature:DrawerMenuItem.kt$@Composable fun DrawerMenuItem( icon: ImageVector, text: String, onClick: () -&gt; Unit, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:ErrorDialog.kt$@Composable internal fun ErrorDialog( message: String, onDismiss: () -&gt; Unit, )</ID>
    <ID>FunctionSignature:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `onLoginButtonClicked should show install dialog when NIP-55 signer is not installed`()</ID>
    <ID>FunctionSignature:LoginViewModelTest.kt$LoginViewModelTest$@Test fun `processNip55Response should wait for relay list fetch before setting loginSuccess`()</ID>
    <ID>FunctionSignature:MainActivityTest.kt$MainActivityTest$private suspend fun determineInitialDestination( getLoginStateUseCase: GetLoginStateUseCase ): String</ID>
    <ID>FunctionSignature:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response when Nip55Signer not installed should return Nip55SignerNotInstalledError`()</ID>
    <ID>FunctionSignature:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$@Test fun `processNip55Response when Nip55Signer success but local storage fails should return UnknownError`()</ID>
    <ID>FunctionSignature:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$private fun createNip65Event( pubkey: String, tags: List&lt;List&lt;String&gt;&gt;, createdAt: Long = 1234567890L ): NostrEvent</ID>
    <ID>FunctionSignature:NostrRelayMessage.kt$NostrRelayMessageSerializer$private fun deserializeEvent( array: JsonArray, jsonDecoder: JsonDecoder, ): NostrRelayMessage.Event</ID>
    <ID>FunctionSignature:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$@Test fun `login flow - when NIP-55 signer response success - should update UI state and navigate to main`()</ID>
    <ID>FunctionSignature:RelayPool.kt$RelayPool$suspend fun publishEvent( relays: List&lt;RelayConfig&gt;, signedEventJson: String, timeoutMs: Long ): Result&lt;PublishResult&gt;</ID>
    <ID>FunctionSignature:RelayPool.kt$RelayPool$suspend fun subscribeWithTimeout( relays: List&lt;RelayConfig&gt;, filter: String, timeoutMs: Long ): List&lt;NostrEvent&gt;</ID>
    <ID>FunctionSignature:RelayPool.kt$RelayPoolImpl$private suspend fun publishToRelay( relayUrl: String, signedEventJson: String ): Pair&lt;String, String&gt;</ID>
    <ID>FunctionSignature:SettingsScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun SettingsScreen( uiState: SettingsUiState, onThemeModeSelected: (ThemeMode) -&gt; Unit, onNavigateUp: () -&gt; Unit )</ID>
    <ID>FunctionSignature:UrlSelectionDialog.kt$@Composable internal fun UrlSelectionDialog( urls: List&lt;String&gt;, onUrlSelected: (String) -&gt; Unit, onDismiss: () -&gt; Unit, )</ID>
    <ID>IfElseWrapping:BookmarkScreen.kt$if (hasUrls) MaterialTheme.colorScheme.surface else MaterialTheme.colorScheme.surfaceVariant</ID>
    <ID>Indentation:AppDrawer.kt$ </ID>
    <ID>Indentation:AppInfoScreen.kt$ </ID>
    <ID>Indentation:AuthEvent.kt$AuthEvent$ </ID>
    <ID>Indentation:AuthEvent.kt$AuthEvent.UserLoggedIn$ </ID>
    <ID>Indentation:AuthEvent.kt$AuthEvent.UserLoggedOut$ </ID>
    <ID>Indentation:AuthEventTest.kt$AuthEventTest$ </ID>
    <ID>Indentation:AuthRepository.kt$AuthRepository$ </ID>
    <ID>Indentation:Bech32.kt$Bech32$ </ID>
    <ID>Indentation:BookmarkFilterMode.kt$BookmarkFilterMode$ </ID>
    <ID>Indentation:BookmarkRepository.kt$BookmarkRepository$ </ID>
    <ID>Indentation:BookmarkScreen.kt$ </ID>
    <ID>Indentation:BookmarkViewModel.kt$BookmarkViewModel$ </ID>
    <ID>Indentation:BookmarkViewModelTest.kt$BookmarkViewModelTest$ </ID>
    <ID>Indentation:DrawerMenuItem.kt$ </ID>
    <ID>Indentation:ErrorDialog.kt$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError.NetworkError$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError.Nip55SignerNotInstalled$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError.Timeout$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError.UnknownError$ </ID>
    <ID>Indentation:ErrorTypes.kt$LoginError.UserRejected$ </ID>
    <ID>Indentation:ErrorTypes.kt$LogoutError$ </ID>
    <ID>Indentation:ErrorTypes.kt$LogoutError.StorageError$ </ID>
    <ID>Indentation:ErrorTypes.kt$StorageError$ </ID>
    <ID>Indentation:ErrorTypes.kt$StorageError.ReadError$ </ID>
    <ID>Indentation:ErrorTypes.kt$StorageError.WriteError$ </ID>
    <ID>Indentation:ErrorTypesTest.kt$ErrorTypesTest$ </ID>
    <ID>Indentation:FetchRelayListUseCase.kt$FetchRelayListUseCase$ </ID>
    <ID>Indentation:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$ </ID>
    <ID>Indentation:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl.Companion$ </ID>
    <ID>Indentation:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$ </ID>
    <ID>Indentation:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest.Companion$ </ID>
    <ID>Indentation:GetBookmarkListUseCase.kt$GetBookmarkListUseCase$ </ID>
    <ID>Indentation:GetBookmarkListUseCaseImpl.kt$GetBookmarkListUseCaseImpl$ </ID>
    <ID>Indentation:GetLoginStateUseCase.kt$GetLoginStateUseCase$ </ID>
    <ID>Indentation:GetLoginStateUseCaseTest.kt$GetLoginStateUseCaseTest$ </ID>
    <ID>Indentation:LicenseScreen.kt$ </ID>
    <ID>Indentation:LocalAuthDataSource.kt$LocalAuthDataSource$ </ID>
    <ID>Indentation:LocalAuthDataSource.kt$LocalAuthDataSource.Companion$ </ID>
    <ID>Indentation:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$ </ID>
    <ID>Indentation:LocalSettingsDataSource.kt$LocalSettingsDataSource$ </ID>
    <ID>Indentation:LocalSettingsDataSource.kt$LocalSettingsDataSource.Companion$ </ID>
    <ID>Indentation:LocalSettingsDataSourceTest.kt$LocalSettingsDataSourceTest$ </ID>
    <ID>Indentation:LoginScreen.kt$ </ID>
    <ID>Indentation:LoginUseCase.kt$LoginUseCase$ </ID>
    <ID>Indentation:LoginUseCaseTest.kt$LoginUseCaseTest$ </ID>
    <ID>Indentation:LoginViewModel.kt$LoginViewModel$ </ID>
    <ID>Indentation:LoginViewModel.kt$LoginViewModel.Companion$ </ID>
    <ID>Indentation:LoginViewModelTest.kt$LoginViewModelTest$ </ID>
    <ID>Indentation:LogoutUseCase.kt$LogoutUseCase$ </ID>
    <ID>Indentation:LogoutUseCaseTest.kt$LogoutUseCaseTest$ </ID>
    <ID>Indentation:MainActivity.kt$ </ID>
    <ID>Indentation:MainActivity.kt$MainActivity$ </ID>
    <ID>Indentation:MainActivityTest.kt$MainActivityTest$ </ID>
    <ID>Indentation:MainScreen.kt$ </ID>
    <ID>Indentation:NetworkModule.kt$NetworkModule$ </ID>
    <ID>Indentation:Nip55AuthRepository.kt$Nip55AuthRepository$ </ID>
    <ID>Indentation:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$ </ID>
    <ID>Indentation:Nip55GetLoginStateUseCase.kt$Nip55GetLoginStateUseCase$ </ID>
    <ID>Indentation:Nip55LoginUseCase.kt$Nip55LoginUseCase$ </ID>
    <ID>Indentation:Nip55LogoutUseCase.kt$Nip55LogoutUseCase$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error.IntentResolutionError$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error.InvalidResponse$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error.NotInstalled$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error.Timeout$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55Error.UserRejected$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55SignerClient$ </ID>
    <ID>Indentation:Nip55SignerClient.kt$Nip55SignerClient.Companion$ </ID>
    <ID>Indentation:Nip55SignerClientTest.kt$Nip55SignerClientTest$ </ID>
    <ID>Indentation:Nip65EventParser.kt$Nip65EventParser$ </ID>
    <ID>Indentation:Nip65EventParser.kt$Nip65EventParserImpl$ </ID>
    <ID>Indentation:Nip65EventParser.kt$Nip65EventParserImpl.Companion$ </ID>
    <ID>Indentation:Nip65EventParserTest.kt$Nip65EventParserTest$ </ID>
    <ID>Indentation:Nip65RelayListFetcher.kt$Nip65RelayListFetcher$ </ID>
    <ID>Indentation:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$ </ID>
    <ID>Indentation:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl.Companion$ </ID>
    <ID>Indentation:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage.Closed$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage.Eose$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage.Event$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage.Ok$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessage.Unknown$ </ID>
    <ID>Indentation:NostrRelayMessage.kt$NostrRelayMessageSerializer$ </ID>
    <ID>Indentation:PostBookmarkScreen.kt$ </ID>
    <ID>Indentation:PostBookmarkUseCase.kt$PostBookmarkUseCase$ </ID>
    <ID>Indentation:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$ </ID>
    <ID>Indentation:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$ </ID>
    <ID>Indentation:PostBookmarkViewModel.kt$PostBookmarkViewModel$ </ID>
    <ID>Indentation:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$ </ID>
    <ID>Indentation:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$ </ID>
    <ID>Indentation:RelayBookmarkRepository.kt$RelayBookmarkRepository$ </ID>
    <ID>Indentation:RelayBookmarkRepository.kt$RelayBookmarkRepository.Companion$ </ID>
    <ID>Indentation:RelayConfigTest.kt$RelayConfigTest$ </ID>
    <ID>Indentation:RelayPool.kt$RelayPool$ </ID>
    <ID>Indentation:RelayPool.kt$RelayPoolImpl$ </ID>
    <ID>Indentation:RelayPool.kt$RelayPoolImpl.&lt;no name provided&gt;$ </ID>
    <ID>Indentation:RelayPool.kt$RelayPoolImpl.Companion$ </ID>
    <ID>Indentation:RelayPoolTest.kt$RelayPoolTest$ </ID>
    <ID>Indentation:RelayPoolTest.kt$RelayPoolTest.MockPublishWebSocketState$ </ID>
    <ID>Indentation:RelayPoolTest.kt$RelayPoolTest.MockWebSocketState$ </ID>
    <ID>Indentation:RepositoryModule.kt$RepositoryModule$ </ID>
    <ID>Indentation:SettingsRepository.kt$SettingsRepository$ </ID>
    <ID>Indentation:SettingsRepositoryImpl.kt$SettingsRepositoryImpl$ </ID>
    <ID>Indentation:SettingsRepositoryImplTest.kt$SettingsRepositoryImplTest$ </ID>
    <ID>Indentation:SettingsScreen.kt$ </ID>
    <ID>Indentation:SettingsViewModel.kt$SettingsViewModel$ </ID>
    <ID>Indentation:SettingsViewModelTest.kt$SettingsViewModelTest$ </ID>
    <ID>Indentation:Theme.kt$ </ID>
    <ID>Indentation:ThemeMode.kt$ThemeMode$ </ID>
    <ID>Indentation:ThemeModeTest.kt$ThemeModeTest$ </ID>
    <ID>Indentation:UnsignedNostrEvent.kt$UnsignedNostrEvent$ </ID>
    <ID>Indentation:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$ </ID>
    <ID>Indentation:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher.Companion$ </ID>
    <ID>Indentation:UrlMetadataFetcher.kt$UrlMetadataFetcher$ </ID>
    <ID>Indentation:UrlSelectionDialog.kt$ </ID>
    <ID>Indentation:UseCaseModule.kt$UseCaseModule$ </ID>
    <ID>Indentation:User.kt$ </ID>
    <ID>Indentation:User.kt$User$ </ID>
    <ID>Indentation:UserTest.kt$UserTest$ </ID>
    <ID>LabeledExpression:BookmarkViewModel.kt$BookmarkViewModel$@launch</ID>
    <ID>LabeledExpression:PostBookmarkViewModel.kt$PostBookmarkViewModel$@launch</ID>
    <ID>LabeledExpression:RelayBookmarkRepository.kt$RelayBookmarkRepository$@forEach</ID>
    <ID>LabeledExpression:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$@withContext</ID>
    <ID>LongMethod:BookmarkScreen.kt$@Composable private fun BookmarkItemCard(bookmark: BookmarkItem, onClick: (BookmarkItem) -&gt; Unit)</ID>
    <ID>LongMethod:BookmarkScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun BookmarkScreen( uiState: BookmarkUiState, onRefresh: () -&gt; Unit, onLoad: () -&gt; Unit, onOpenDrawer: () -&gt; Unit = {}, onTabSelected: (BookmarkFilterMode) -&gt; Unit = {}, onAddBookmark: () -&gt; Unit = {}, viewModel: BookmarkViewModel? = null, )</ID>
    <ID>LongMethod:LoginScreen.kt$@Composable fun LoginScreen( uiState: LoginUiState, onLoginButtonClick: () -&gt; Unit, onDismissDialog: () -&gt; Unit = {}, onInstallNip55Signer: () -&gt; Unit = {}, onRetry: () -&gt; Unit = {}, onLoginSuccess: () -&gt; Unit = {} )</ID>
    <ID>LongMethod:PostBookmarkScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun PostBookmarkScreen( uiState: PostBookmarkUiState, onUrlChange: (String) -&gt; Unit, onTitleChange: (String) -&gt; Unit, onCategoriesChange: (String) -&gt; Unit, onCommentChange: (String) -&gt; Unit, onPostClick: () -&gt; Unit, onNavigateBack: () -&gt; Unit, onDismissError: () -&gt; Unit )</ID>
    <ID>LongMethod:RelayBookmarkRepository.kt$RelayBookmarkRepository$override suspend fun getBookmarkList(pubkey: String): Result&lt;BookmarkList?&gt;</ID>
    <ID>LongParameterList:PostBookmarkScreen.kt$( uiState: PostBookmarkUiState, onUrlChange: (String) -&gt; Unit, onTitleChange: (String) -&gt; Unit, onCategoriesChange: (String) -&gt; Unit, onCommentChange: (String) -&gt; Unit, onPostClick: () -&gt; Unit, onNavigateBack: () -&gt; Unit, onDismissError: () -&gt; Unit )</ID>
    <ID>MagicNumber:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$63</ID>
    <ID>MagicNumber:MainScreen.kt$16</ID>
    <ID>MagicNumber:MainScreen.kt$8</ID>
    <ID>MagicNumber:NetworkModule.kt$NetworkModule$10</ID>
    <ID>MagicNumber:Nip55SignerClient.kt$Nip55SignerClient$16</ID>
    <ID>MagicNumber:Nip55SignerClient.kt$Nip55SignerClient$8</ID>
    <ID>MagicNumber:NostrRelayMessage.kt$NostrRelayMessageSerializer$3</ID>
    <ID>MagicNumber:RelayPool.kt$RelayPoolImpl$1000</ID>
    <ID>MagicNumber:RelayPool.kt$RelayPoolImpl.&lt;no name provided&gt;$1000</ID>
    <ID>MaxLineLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$"""[{"url":"wss://relay1.example.com","read":true,"write":true},{"url":"wss://relay2.example.com","read":true,"write":false}]"""</ID>
    <ID>MaxLineLength:RelayPoolTest.kt$RelayPoolTest$"""{"id":"event123","pubkey":"abc","created_at":1234567890,"kind":39701,"tags":[],"content":"test","sig":"xyz"}"""</ID>
    <ID>MaxLineLength:RelayPoolTest.kt$RelayPoolTest.MockWebSocketState$return """["EVENT","$subscriptionId",{"id":"${event.id}","pubkey":"${event.pubkey}","created_at":${event.createdAt},"kind":${event.kind},"tags":[$tagsJson],"content":"${event.content}"}]"""</ID>
    <ID>MaximumLineLength:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$ </ID>
    <ID>MaximumLineLength:RelayPoolTest.kt$RelayPoolTest$ </ID>
    <ID>MaximumLineLength:RelayPoolTest.kt$RelayPoolTest.MockWebSocketState$ </ID>
    <ID>MultiLineIfElse:BookmarkScreen.kt$MaterialTheme.colorScheme.surface</ID>
    <ID>MultiLineIfElse:BookmarkScreen.kt$MaterialTheme.colorScheme.surfaceVariant</ID>
    <ID>NoEmptyFirstLineInClassBody:AuthEventTest.kt$AuthEventTest${ /** Test that UserLoggedIn event can be created */ @Test fun `create UserLoggedIn event`() { val user = User("npub1" + "a".repeat(59)) val event = AuthEvent.UserLoggedIn(user) assertTrue(event is AuthEvent) assertTrue(event is AuthEvent.UserLoggedIn) assertEquals(user, event.user) } /** Test that UserLoggedOut event can be created */ @Test fun `create UserLoggedOut event`() { val event = AuthEvent.UserLoggedOut assertTrue(event is AuthEvent) assertTrue(event is AuthEvent.UserLoggedOut) } /** Test UserLoggedIn event equality */ @Test fun `UserLoggedIn events with same user are equal`() { val user = User("npub1" + "a".repeat(59)) val event1 = AuthEvent.UserLoggedIn(user) val event2 = AuthEvent.UserLoggedIn(user) assertEquals(event1, event2) } /** Test UserLoggedIn events with different users are not equal */ @Test fun `UserLoggedIn events with different users are not equal`() { val user1 = User("npub1" + "a".repeat(59)) val user2 = User("npub1" + "b".repeat(59)) val event1 = AuthEvent.UserLoggedIn(user1) val event2 = AuthEvent.UserLoggedIn(user2) assertNotEquals(event1, event2) } /** Test UserLoggedOut event singleton nature */ @Test fun `UserLoggedOut is singleton`() { val event1 = AuthEvent.UserLoggedOut val event2 = AuthEvent.UserLoggedOut assertSame(event1, event2) } /** Test AuthEvent sealed class properties（when expression exhaustiveness） */ @Test fun `AuthEvent sealed class allows exhaustive when`() { val user = User("npub1" + "a".repeat(59)) val loggedInEvent: AuthEvent = AuthEvent.UserLoggedIn(user) val loggedOutEvent: AuthEvent = AuthEvent.UserLoggedOut // Verify when expression is exhaustive（compile-time check） val loggedInResult = when (loggedInEvent) { is AuthEvent.UserLoggedIn -&gt; "logged_in" is AuthEvent.UserLoggedOut -&gt; "logged_out" } val loggedOutResult = when (loggedOutEvent) { is AuthEvent.UserLoggedIn -&gt; "logged_in" is AuthEvent.UserLoggedOut -&gt; "logged_out" } assertEquals("logged_in", loggedInResult) assertEquals("logged_out", loggedOutResult) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:AuthRepository.kt$AuthRepository${ /** * Get login state * * Retrieves saved user information from LocalAuthDataSource. * * @return User if logged in, null if not logged in */ suspend fun getLoginState(): User? /** * Save login state * * Saves user information to LocalAuthDataSource. * * @param user User to save * @return Success on success, Failure(StorageError) on failure */ suspend fun saveLoginState(user: User): Result&lt;Unit&gt; /** * Logout * * Clears login state in LocalAuthDataSource. * * @return Success on success, Failure(LogoutError) on failure */ suspend fun logout(): Result&lt;Unit&gt; /** * Process NIP-55 signer response and set user to logged-in state * * Parses response with Nip55SignerClient and saves to LocalAuthDataSource on success. * * @param resultCode ActivityResult's resultCode * @param data Intent data * @return Success(User) on success, Failure(LoginError) on failure */ suspend fun processNip55Response(resultCode: Int, data: Intent?): Result&lt;User&gt; /** * Check if NIP-55 signer app is installed * * Delegates to Nip55SignerClient to verify NIP-55 signer installation status. * * @return true if NIP-55 signer is installed */ fun checkNip55SignerInstalled(): Boolean }</ID>
    <ID>NoEmptyFirstLineInClassBody:BookmarkViewModel.kt$BookmarkViewModel${ private val _uiState = MutableStateFlow(BookmarkUiState()) val uiState: StateFlow&lt;BookmarkUiState&gt; = _uiState.asStateFlow() /** * Load bookmarks for the current logged-in user * * Fetches all bookmarks from relays, stores in shared data pool, and applies filter based on * selected tab. */ fun loadBookmarks() { viewModelScope.launch { _uiState.value = _uiState.value.copy(isLoading = true, error = null) val user = getLoginStateUseCase() if (user == null) { _uiState.value = _uiState.value.copy( isLoading = false, error = "Not logged in", allBookmarks = emptyList(), bookmarks = emptyList()) return@launch } val userHexPubkey = Bech32.npubToHex(user.pubkey) val result = getBookmarkListUseCase(user.pubkey) result.fold( onSuccess = { bookmarkList -&gt; val allItems = bookmarkList?.items ?: emptyList() _uiState.update { state -&gt; val updatedState = state.copy( isLoading = false, allBookmarks = allItems, userHexPubkey = userHexPubkey, error = null) updatedState.copy(bookmarks = filterBookmarks(updatedState)) } }, onFailure = { e -&gt; _uiState.value = _uiState.value.copy( isLoading = false, error = e.message ?: "Failed to load bookmarks") }) } } /** * Select bookmark filter tab * * Applies filter based on selected tab without re-fetching data from relay. * * @param tab The filter mode to select (Local or Global) */ fun selectTab(tab: BookmarkFilterMode) { _uiState.update { state -&gt; if (state.selectedTab != tab) { val newState = state.copy(selectedTab = tab) newState.copy(bookmarks = filterBookmarks(newState)) } else { state } } } /** * Filter bookmarks based on selected tab * * Local tab shows only bookmarks authored by the logged-in user. Global tab shows all bookmarks. * * @param state Current UI state to filter from * @return Filtered list of bookmarks */ private fun filterBookmarks(state: BookmarkUiState): List&lt;BookmarkItem&gt; { return when (state.selectedTab) { BookmarkFilterMode.Local -&gt; { state.userHexPubkey?.let { hexPubkey -&gt; state.allBookmarks.filter { it.event?.author == hexPubkey } } ?: emptyList() } BookmarkFilterMode.Global -&gt; state.allBookmarks } } /** Refresh bookmark list by reloading from relays */ fun refresh() { loadBookmarks() } /** * Handle bookmark card click * * Shows URL selection dialog for bookmarks with multiple URLs */ fun onBookmarkCardClicked(bookmark: BookmarkItem) { _uiState.value = _uiState.value.copy(selectedBookmarkForUrlDialog = bookmark) } /** Dismiss URL selection dialog */ fun dismissUrlDialog() { _uiState.value = _uiState.value.copy(selectedBookmarkForUrlDialog = null) } /** * Set URL opening error message * * @param error Error message to display */ fun setUrlOpenError(error: String) { _uiState.value = _uiState.value.copy(urlOpenError = error) } /** Dismiss error dialog */ fun dismissErrorDialog() { _uiState.value = _uiState.value.copy(urlOpenError = null) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:BookmarkViewModelTest.kt$BookmarkViewModelTest${ private lateinit var getBookmarkListUseCase: GetBookmarkListUseCase private lateinit var getLoginStateUseCase: GetLoginStateUseCase private lateinit var viewModel: BookmarkViewModel private val testDispatcher = StandardTestDispatcher() @Before fun setup() { Dispatchers.setMain(testDispatcher) getBookmarkListUseCase = mockk(relaxed = true) getLoginStateUseCase = mockk(relaxed = true) viewModel = BookmarkViewModel(getBookmarkListUseCase, getLoginStateUseCase) } @After fun tearDown() { Dispatchers.resetMain() } @Test fun `initial BookmarkUiState should have default values`() = runTest { val state = viewModel.uiState.first() assertFalse("isLoading should be false", state.isLoading) assertTrue("bookmarks should be empty", state.bookmarks.isEmpty()) assertNull("error should be null", state.error) assertNull("selectedBookmarkForUrlDialog should be null", state.selectedBookmarkForUrlDialog) assertNull("urlOpenError should be null", state.urlOpenError) } @Test fun `selectTab to Global should update selectedTab`() = runTest { viewModel.selectTab(BookmarkFilterMode.Global) val state = viewModel.uiState.first() assertEquals( "selectedTab should be Global after selecting", BookmarkFilterMode.Global, state.selectedTab) } @Test fun `selectTab with same tab should not trigger state update`() = runTest { val initialState = viewModel.uiState.first() viewModel.selectTab(BookmarkFilterMode.Local) val newState = viewModel.uiState.first() assertSame("State should be same reference when selecting same tab", initialState, newState) } @Test fun `Global tab should show all bookmarks from allBookmarks`() = runTest { val testBookmarks = listOf( createTestBookmarkItem("id1", "author1"), createTestBookmarkItem("id2", "author2"), createTestBookmarkItem("id3", "author1")) setViewModelState(allBookmarks = testBookmarks, userHexPubkey = "author1") viewModel.selectTab(BookmarkFilterMode.Global) val state = viewModel.uiState.first() assertEquals("Global tab should show all bookmarks", testBookmarks, state.bookmarks) } @Test fun `Local tab should filter bookmarks by userHexPubkey`() = runTest { val testBookmarks = listOf( createTestBookmarkItem("id1", "author1"), createTestBookmarkItem("id2", "author2"), createTestBookmarkItem("id3", "author1")) setViewModelState( allBookmarks = testBookmarks, userHexPubkey = "author1", selectedTab = BookmarkFilterMode.Global) viewModel.selectTab(BookmarkFilterMode.Local) val state = viewModel.uiState.first() assertEquals("Local tab should show only user's bookmarks", 2, state.bookmarks.size) assertTrue( "All bookmarks should have matching author", state.bookmarks.all { it.event?.author == "author1" }) } @Test fun `Local tab with null userHexPubkey should show empty list`() = runTest { val testBookmarks = listOf(createTestBookmarkItem("id1", "author1"), createTestBookmarkItem("id2", "author2")) setViewModelState(allBookmarks = testBookmarks, userHexPubkey = null) viewModel.selectTab(BookmarkFilterMode.Local) val state = viewModel.uiState.first() assertTrue("Local tab with null userHexPubkey should be empty", state.bookmarks.isEmpty()) } private fun createTestBookmarkItem(eventId: String, author: String): BookmarkItem { return BookmarkItem( type = "event", eventId = eventId, title = "Test $eventId", urls = listOf("https://example.com/$eventId"), event = io.github.omochice.pinosu.domain.model.BookmarkedEvent( kind = 39701, content = "content", author = author, createdAt = System.currentTimeMillis() / 1000, tags = emptyList())) } private fun setViewModelState( allBookmarks: List&lt;BookmarkItem&gt; = emptyList(), userHexPubkey: String? = null, selectedTab: BookmarkFilterMode = BookmarkFilterMode.Local ) { val currentState = viewModel.uiState.value val field = viewModel::class.java.getDeclaredField("_uiState") field.isAccessible = true @Suppress("UNCHECKED_CAST") val mutableStateFlow = field.get(viewModel) as kotlinx.coroutines.flow.MutableStateFlow&lt;BookmarkUiState&gt; mutableStateFlow.value = currentState.copy( allBookmarks = allBookmarks, userHexPubkey = userHexPubkey, selectedTab = selectedTab) } @Test fun `onBookmarkCardClicked with multiple URLs should set selectedBookmarkForUrlDialog`() = runTest { val bookmarkWithMultipleUrls = BookmarkItem( type = "event", eventId = "test789", title = "Multiple URLs Bookmark", urls = listOf( "https://example.com/1", "https://example.com/2", "https://example.com/3")) viewModel.onBookmarkCardClicked(bookmarkWithMultipleUrls) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull( "selectedBookmarkForUrlDialog should be set for multiple URLs", state.selectedBookmarkForUrlDialog) assertEquals( "selectedBookmarkForUrlDialog should be the clicked bookmark", bookmarkWithMultipleUrls, state.selectedBookmarkForUrlDialog) } @Test fun `dismissUrlDialog should clear selectedBookmarkForUrlDialog`() = runTest { val bookmarkWithMultipleUrls = BookmarkItem( type = "event", eventId = "test999", title = "Test Dismiss", urls = listOf("https://example.com/a", "https://example.com/b")) viewModel.onBookmarkCardClicked(bookmarkWithMultipleUrls) advanceUntilIdle() viewModel.dismissUrlDialog() advanceUntilIdle() val state = viewModel.uiState.first() assertNull( "selectedBookmarkForUrlDialog should be null after dismissing", state.selectedBookmarkForUrlDialog) } @Test fun `setUrlOpenError should set error message`() = runTest { val errorMessage = "Failed to open URL" viewModel.setUrlOpenError(errorMessage) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("urlOpenError should be set", state.urlOpenError) assertEquals("urlOpenError should contain the error message", errorMessage, state.urlOpenError) } @Test fun `dismissErrorDialog should clear urlOpenError`() = runTest { viewModel.setUrlOpenError("Some error") advanceUntilIdle() viewModel.dismissErrorDialog() advanceUntilIdle() val state = viewModel.uiState.first() assertNull("urlOpenError should be null after dismissing", state.urlOpenError) } @Test fun `loadBookmarks should set isLoading to true initially`() = runTest { val testUser = User("npub1test") coEvery { getLoginStateUseCase() } returns testUser coEvery { getBookmarkListUseCase(any()) } coAnswers { kotlinx.coroutines.delay(100) Result.success(BookmarkList("test", emptyList(), 0L)) } viewModel.loadBookmarks() testScheduler.runCurrent() val state = viewModel.uiState.first() assertTrue("isLoading should be true during loading", state.isLoading) } @Test fun `loadBookmarks should store bookmarks in allBookmarks`() = runTest { val testUser = User("npub1test") val testBookmarks = listOf( BookmarkItem( type = "event", eventId = "id1", title = "Bookmark 1", urls = listOf("https://example.com/1"))) val bookmarkList = BookmarkList("test", testBookmarks, 0L) coEvery { getLoginStateUseCase() } returns testUser coEvery { getBookmarkListUseCase(any()) } returns Result.success(bookmarkList) viewModel.loadBookmarks() advanceUntilIdle() val state = viewModel.uiState.first() assertFalse("isLoading should be false after loading", state.isLoading) assertEquals("allBookmarks should be set", testBookmarks, state.allBookmarks) assertNull("error should be null on success", state.error) } @Test fun `loadBookmarks should set error when not logged in`() = runTest { coEvery { getLoginStateUseCase() } returns null viewModel.loadBookmarks() advanceUntilIdle() val state = viewModel.uiState.first() assertFalse("isLoading should be false", state.isLoading) assertEquals("error should indicate not logged in", "Not logged in", state.error) assertTrue("bookmarks should be empty", state.bookmarks.isEmpty()) } @Test fun `loadBookmarks should set error on failure`() = runTest { val testUser = User("npub1test") val errorMessage = "Network error" coEvery { getLoginStateUseCase() } returns testUser coEvery { getBookmarkListUseCase(any()) } returns Result.failure(Exception(errorMessage)) viewModel.loadBookmarks() advanceUntilIdle() val state = viewModel.uiState.first() assertFalse("isLoading should be false", state.isLoading) assertEquals("error should be set", errorMessage, state.error) } @Test fun `refresh should call loadBookmarks`() = runTest { val testUser = User("npub1test") coEvery { getLoginStateUseCase() } returns testUser coEvery { getBookmarkListUseCase(any()) } returns Result.success(BookmarkList("test", emptyList(), 0L)) viewModel.refresh() advanceUntilIdle() coVerify { getBookmarkListUseCase(any()) } } @Test fun `multiple URL dialog workflow should work correctly`() = runTest { val bookmark = BookmarkItem( type = "event", eventId = "workflow-test", title = "Workflow Test", urls = listOf("https://example.com/1", "https://example.com/2")) viewModel.onBookmarkCardClicked(bookmark) advanceUntilIdle() var state = viewModel.uiState.first() assertNotNull("Dialog should be shown", state.selectedBookmarkForUrlDialog) viewModel.dismissUrlDialog() advanceUntilIdle() state = viewModel.uiState.first() assertNull("Dialog should be dismissed", state.selectedBookmarkForUrlDialog) } @Test fun `error dialog workflow should work correctly`() = runTest { viewModel.setUrlOpenError("Test error") advanceUntilIdle() var state = viewModel.uiState.first() assertNotNull("Error should be shown", state.urlOpenError) viewModel.dismissErrorDialog() advanceUntilIdle() state = viewModel.uiState.first() assertNull("Error should be dismissed", state.urlOpenError) } @Test fun `state should handle concurrent dialog states independently`() = runTest { val bookmark = BookmarkItem( type = "event", eventId = "concurrent-test", title = "Concurrent Test", urls = listOf("https://example.com/1", "https://example.com/2")) viewModel.onBookmarkCardClicked(bookmark) viewModel.setUrlOpenError("Test error") advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("URL dialog should be shown", state.selectedBookmarkForUrlDialog) assertNotNull("Error dialog should be shown", state.urlOpenError) viewModel.dismissUrlDialog() advanceUntilIdle() val stateAfterDismissUrl = viewModel.uiState.first() assertNull("URL dialog should be dismissed", stateAfterDismissUrl.selectedBookmarkForUrlDialog) assertNotNull("Error dialog should still be shown", stateAfterDismissUrl.urlOpenError) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:ErrorTypesTest.kt$ErrorTypesTest${ /** Test that LoginError.Nip55SignerNotInstalled can be created */ @Test fun `create LoginError Nip55SignerNotInstalled`() { val error = LoginError.Nip55SignerNotInstalled assertTrue(error is LoginError) assertTrue(error is LoginError.Nip55SignerNotInstalled) } /** Test that LoginError.UserRejected can be created */ @Test fun `create LoginError UserRejected`() { val error = LoginError.UserRejected assertTrue(error is LoginError) assertTrue(error is LoginError.UserRejected) } /** Test that LoginError.Timeout can be created */ @Test fun `create LoginError Timeout`() { val error = LoginError.Timeout assertTrue(error is LoginError) assertTrue(error is LoginError.Timeout) } /** Test that LoginError.NetworkError can be created */ @Test fun `create LoginError NetworkError with message`() { val message = "Connection failed" val error = LoginError.NetworkError(message) assertTrue(error is LoginError) assertTrue(error is LoginError.NetworkError) assertEquals(message, error.message) } /** Test that LoginError.UnknownError can be created */ @Test fun `create LoginError UnknownError with throwable`() { val throwable = RuntimeException("Test exception") val error = LoginError.UnknownError(throwable) assertTrue(error is LoginError) assertTrue(error is LoginError.UnknownError) assertEquals(throwable, error.throwable) } /** Test LoginError when expression exhaustiveness */ @Test fun `LoginError sealed class allows exhaustive when`() { val errors: List&lt;LoginError&gt; = listOf( LoginError.Nip55SignerNotInstalled, LoginError.UserRejected, LoginError.Timeout, LoginError.NetworkError("test"), LoginError.UnknownError(RuntimeException())) errors.forEach { error -&gt; val result = when (error) { is LoginError.Nip55SignerNotInstalled -&gt; "nip55_signer_not_installed" is LoginError.UserRejected -&gt; "user_rejected" is LoginError.Timeout -&gt; "timeout" is LoginError.NetworkError -&gt; "network_error" is LoginError.UnknownError -&gt; "unknown_error" } assertNotNull(result) } } /** Test that LogoutError.StorageError can be created */ @Test fun `create LogoutError StorageError with message`() { val message = "Failed to clear storage" val error = LogoutError.StorageError(message) assertTrue(error is LogoutError) assertTrue(error is LogoutError.StorageError) assertEquals(message, error.message) } /** Test LogoutError when expression exhaustiveness */ @Test fun `LogoutError sealed class allows exhaustive when`() { val error: LogoutError = LogoutError.StorageError("test") val result = when (error) { is LogoutError.StorageError -&gt; "storage_error" } assertEquals("storage_error", result) } /** Test StorageError.WriteError can be created */ @Test fun `create StorageError WriteError with message`() { val message = "Write failed" val error = StorageError.WriteError(message) assertTrue(error is StorageError) assertTrue(error is StorageError.WriteError) assertEquals(message, error.message) } /** Test StorageError.ReadError can be created */ @Test fun `create StorageError ReadError with message`() { val message = "Read failed" val error = StorageError.ReadError(message) assertTrue(error is StorageError) assertTrue(error is StorageError.ReadError) assertEquals(message, error.message) } /** Test StorageError when expression exhaustiveness */ @Test fun `StorageError sealed class allows exhaustive when`() { val errors: List&lt;StorageError&gt; = listOf(StorageError.WriteError("write"), StorageError.ReadError("read")) errors.forEach { error -&gt; val result = when (error) { is StorageError.WriteError -&gt; "write_error" is StorageError.ReadError -&gt; "read_error" } assertNotNull(result) } } /** Test Nip55Error.NotInstalled can be created */ @Test fun `create Nip55Error NotInstalled`() { val error = Nip55Error.NotInstalled assertTrue(error is Nip55Error) assertTrue(error is Nip55Error.NotInstalled) } /** Test Nip55Error.UserRejected can be created */ @Test fun `create Nip55Error UserRejected`() { val error = Nip55Error.UserRejected assertTrue(error is Nip55Error) assertTrue(error is Nip55Error.UserRejected) } /** Test Nip55Error.Timeout can be created */ @Test fun `create Nip55Error Timeout`() { val error = Nip55Error.Timeout assertTrue(error is Nip55Error) assertTrue(error is Nip55Error.Timeout) } /** Test Nip55Error.InvalidResponse can be created */ @Test fun `create Nip55Error InvalidResponse with message`() { val message = "Invalid response format" val error = Nip55Error.InvalidResponse(message) assertTrue(error is Nip55Error) assertTrue(error is Nip55Error.InvalidResponse) assertEquals(message, error.message) } /** Test Nip55Error.IntentResolutionError can be created */ @Test fun `create Nip55Error IntentResolutionError with message`() { val message = "Intent resolution failed" val error = Nip55Error.IntentResolutionError(message) assertTrue(error is Nip55Error) assertTrue(error is Nip55Error.IntentResolutionError) assertEquals(message, error.message) } /** Test Nip55Error when expression exhaustiveness */ @Test fun `Nip55Error sealed class allows exhaustive when`() { val errors: List&lt;Nip55Error&gt; = listOf( Nip55Error.NotInstalled, Nip55Error.UserRejected, Nip55Error.Timeout, Nip55Error.InvalidResponse("test"), Nip55Error.IntentResolutionError("test")) errors.forEach { error -&gt; val result = when (error) { is Nip55Error.NotInstalled -&gt; "not_installed" is Nip55Error.UserRejected -&gt; "user_rejected" is Nip55Error.Timeout -&gt; "timeout" is Nip55Error.InvalidResponse -&gt; "invalid_response" is Nip55Error.IntentResolutionError -&gt; "intent_resolution_error" } assertNotNull(result) } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:FetchRelayListUseCase.kt$FetchRelayListUseCase${ /** * Fetch relay list for the given public key and cache it locally * * @param npubPubkey Bech32-encoded public key (npub1...) * @return Success(List&lt;RelayConfig&gt;) with fetched relays (may be empty), Failure if npub is * invalid or fetch fails */ suspend operator fun invoke(npubPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl${ companion object { private const val TAG = "FetchRelayListUseCase" } override suspend fun invoke(npubPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt; { if (!npubPubkey.startsWith("npub1") || npubPubkey.length != 63) { return Result.failure( IllegalArgumentException("Invalid npub format: must be Bech32-encoded (npub1...)")) } val hexPubkey = try { Bech32.npubToHex(npubPubkey) } catch (e: Exception) { null } ?: return Result.failure( IllegalArgumentException("Invalid npub format: must be Bech32-encoded (npub1...)")) val fetchResult = fetcher.fetchRelayList(hexPubkey) if (fetchResult.isFailure) { return fetchResult } val relays = fetchResult.getOrNull() ?: emptyList() try { localAuthDataSource.saveRelayList(relays) } catch (e: Exception) { Log.w(TAG, "Failed to cache relay list: ${e.message}") } return Result.success(relays) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest${ private lateinit var fetcher: Nip65RelayListFetcher private lateinit var localAuthDataSource: LocalAuthDataSource private lateinit var useCase: FetchRelayListUseCase companion object { /** * Valid test npub for testing. This is fiatjaf's npub (well-known Nostr developer) which is a * real Bech32-encoded public key that passes checksum validation. */ const val TEST_VALID_NPUB = "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m" const val TEST_VALID_HEX = "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2" } @Before fun setup() { fetcher = mockk(relaxed = true) localAuthDataSource = mockk(relaxed = true) useCase = FetchRelayListUseCaseImpl(fetcher, localAuthDataSource) } @Test fun `invoke should fetch relay list and cache it on success`() = runTest { val relays = listOf(RelayConfig(url = "wss://relay.example.com")) coEvery { fetcher.fetchRelayList(TEST_VALID_HEX) } returns Result.success(relays) coEvery { localAuthDataSource.saveRelayList(relays) } just runs val result = useCase(TEST_VALID_NPUB) assertTrue("Should return success", result.isSuccess) assertEquals("Should return fetched relays", relays, result.getOrNull()) coVerify { fetcher.fetchRelayList(TEST_VALID_HEX) } coVerify { localAuthDataSource.saveRelayList(relays) } } @Test fun `invoke should return failure for invalid npub format`() = runTest { val invalidNpub = "not-a-valid-npub" val result = useCase(invalidNpub) assertTrue("Should return failure for invalid npub", result.isFailure) } @Test fun `invoke should propagate fetch failure`() = runTest { val error = RuntimeException("Network error") coEvery { fetcher.fetchRelayList(TEST_VALID_HEX) } returns Result.failure(error) val result = useCase(TEST_VALID_NPUB) assertTrue("Should return failure on fetch error", result.isFailure) assertEquals( "Should propagate original error message", "Network error", result.exceptionOrNull()?.message) } @Test fun `invoke should still return success when cache fails`() = runTest { val relays = listOf(RelayConfig(url = "wss://relay.example.com")) coEvery { fetcher.fetchRelayList(TEST_VALID_HEX) } returns Result.success(relays) coEvery { localAuthDataSource.saveRelayList(any()) } throws StorageError.WriteError("Cache error") val result = useCase(TEST_VALID_NPUB) assertTrue("Should return success even when cache fails", result.isSuccess) assertEquals("Should return fetched relays", relays, result.getOrNull()) } @Test fun `invoke should return empty list when no NIP-65 event found`() = runTest { coEvery { fetcher.fetchRelayList(TEST_VALID_HEX) } returns Result.success(emptyList()) coEvery { localAuthDataSource.saveRelayList(any()) } just runs val result = useCase(TEST_VALID_NPUB) assertTrue("Should return success", result.isSuccess) assertTrue("Should return empty list", result.getOrNull()!!.isEmpty()) coVerify { localAuthDataSource.saveRelayList(emptyList()) } } @Test fun `invoke should handle hex pubkey as npub`() = runTest { val hexPubkey = "a".repeat(64) val result = useCase(hexPubkey) assertTrue("Should return failure for hex pubkey (not npub format)", result.isFailure) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:GetBookmarkListUseCaseImpl.kt$GetBookmarkListUseCaseImpl${ /** * Retrieve bookmark list for the specified public key * * @param pubkey Nostr public key (Bech32-encoded format, starts with npub1) * @return Success(BookmarkList) if found, Success(null) if no bookmarks, Failure on error */ override suspend fun invoke(pubkey: String): Result&lt;BookmarkList?&gt; { return bookmarkRepository.getBookmarkList(pubkey) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:GetLoginStateUseCase.kt$GetLoginStateUseCase${ /** * Get the login state * * Delegates to AuthRepository to retrieve user information from local storage. This is a * read-only operation and does not change the login state. * * screen display * * @return User if logged in, null if not logged in */ suspend operator fun invoke(): User? }</ID>
    <ID>NoEmptyFirstLineInClassBody:GetLoginStateUseCaseTest.kt$GetLoginStateUseCaseTest${ private lateinit var authRepository: AuthRepository private lateinit var getLoginStateUseCase: GetLoginStateUseCase @Before fun setup() { authRepository = mockk() getLoginStateUseCase = Nip55GetLoginStateUseCase(authRepository) } @Test fun `invoke returns logged in user when user is logged in`() = runTest { val testPubkey = "npub1" + "a".repeat(59) val testUser = User(testPubkey) coEvery { authRepository.getLoginState() } returns testUser val result = getLoginStateUseCase() assertEquals(testUser, result) coVerify(exactly = 1) { authRepository.getLoginState() } } @Test fun `invoke returns null when user is not logged in`() = runTest { coEvery { authRepository.getLoginState() } returns null val result = getLoginStateUseCase() assertNull(result) coVerify(exactly = 1) { authRepository.getLoginState() } } @Test fun `invoke is read-only operation`() = runTest { val testPubkey = "npub1" + "b".repeat(59) val testUser = User(testPubkey) coEvery { authRepository.getLoginState() } returns testUser getLoginStateUseCase() getLoginStateUseCase() coVerify(exactly = 2) { authRepository.getLoginState() } coVerify(exactly = 0) { authRepository.saveLoginState(any()) } coVerify(exactly = 0) { authRepository.logout() } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest${ private lateinit var sharedPreferences: android.content.SharedPreferences private lateinit var localAuthDataSource: LocalAuthDataSource @Before fun setup() { val context = RuntimeEnvironment.getApplication() sharedPreferences = context.getSharedPreferences("test_prefs", Context.MODE_PRIVATE) sharedPreferences.edit().clear().commit() localAuthDataSource = LocalAuthDataSource(context) localAuthDataSource.setTestSharedPreferences(sharedPreferences) } @Test fun `saveAndGetRelayList round trip should preserve data`() = runTest { val relays = listOf( RelayConfig(url = "wss://relay1.example.com", read = true, write = true), RelayConfig(url = "wss://relay2.example.com", read = true, write = false)) localAuthDataSource.saveRelayList(relays) val result = localAuthDataSource.getRelayList() assertNotNull("Expected relay_list to be retrieved", result) assertEquals(2, result?.size) assertEquals("wss://relay1.example.com", result?.get(0)?.url) assertEquals(true, result?.get(0)?.read) assertEquals(true, result?.get(0)?.write) assertEquals("wss://relay2.example.com", result?.get(1)?.url) assertEquals(true, result?.get(1)?.read) assertEquals(false, result?.get(1)?.write) } @Test fun `getRelayList when saved should return relays`() = runTest { val jsonString = """[{"url":"wss://relay1.example.com","read":true,"write":true},{"url":"wss://relay2.example.com","read":true,"write":false}]""" sharedPreferences.edit().putString("relay_list", jsonString).commit() val result = localAuthDataSource.getRelayList() assertEquals(2, result?.size) assertEquals("wss://relay1.example.com", result?.get(0)?.url) assertEquals(true, result?.get(0)?.read) assertEquals(true, result?.get(0)?.write) assertEquals("wss://relay2.example.com", result?.get(1)?.url) assertEquals(true, result?.get(1)?.read) assertEquals(false, result?.get(1)?.write) } @Test fun `getRelayList when not set should return null`() = runTest { val result = localAuthDataSource.getRelayList() assertNull("Should return null when relay list is not set", result) } @Test fun `clearLoginState should clear relay list`() = runTest { sharedPreferences.edit().putString("relay_list", "test").commit() localAuthDataSource.clearLoginState() assertNull("relay_list should be cleared", sharedPreferences.getString("relay_list", null)) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LocalSettingsDataSourceTest.kt$LocalSettingsDataSourceTest${ private lateinit var sharedPreferences: android.content.SharedPreferences private lateinit var localSettingsDataSource: LocalSettingsDataSource @Before fun setup() { val context = RuntimeEnvironment.getApplication() sharedPreferences = context.getSharedPreferences("test_settings", Context.MODE_PRIVATE) sharedPreferences.edit().clear().commit() localSettingsDataSource = LocalSettingsDataSource(context) localSettingsDataSource.setTestSharedPreferences(sharedPreferences) } @Test fun `default is System`() { val result = localSettingsDataSource.getThemeMode() assertEquals(ThemeMode.System, result) } @Test fun `persists Light`() { localSettingsDataSource.setThemeMode(ThemeMode.Light) val result = localSettingsDataSource.getThemeMode() assertEquals(ThemeMode.Light, result) } @Test fun `persists Dark`() { localSettingsDataSource.setThemeMode(ThemeMode.Dark) val result = localSettingsDataSource.getThemeMode() assertEquals(ThemeMode.Dark, result) } @Test fun `persists System`() { localSettingsDataSource.setThemeMode(ThemeMode.Light) localSettingsDataSource.setThemeMode(ThemeMode.System) val result = localSettingsDataSource.getThemeMode() assertEquals(ThemeMode.System, result) } @Test fun `invalid value returns System`() { sharedPreferences.edit().putInt("theme_mode", 999).commit() val result = localSettingsDataSource.getThemeMode() assertEquals(ThemeMode.System, result) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LoginUseCase.kt$LoginUseCase${ /** * Check if the NIP-55 signer app is installed * * Delegates to AuthRepository to verify NIP-55 signer installation status. * * @return true if NIP-55 signer is installed */ fun checkNip55SignerInstalled(): Boolean }</ID>
    <ID>NoEmptyFirstLineInClassBody:LoginUseCaseTest.kt$LoginUseCaseTest${ private lateinit var authRepository: AuthRepository private lateinit var loginUseCase: LoginUseCase @Before fun setup() { authRepository = mockk(relaxed = true) loginUseCase = Nip55LoginUseCase(authRepository) } @Test fun `checkNip55SignerInstalled when not installed should return false`() { every { authRepository.checkNip55SignerInstalled() } returns false val result = loginUseCase.checkNip55SignerInstalled() assertFalse("Should return false when NIP-55 signer is not installed", result) verify { authRepository.checkNip55SignerInstalled() } } @Test fun `checkNip55SignerInstalled when installed should return true`() { every { authRepository.checkNip55SignerInstalled() } returns true val result = loginUseCase.checkNip55SignerInstalled() assertTrue("Should return true when NIP-55 signer is installed", result) verify { authRepository.checkNip55SignerInstalled() } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LoginViewModel.kt$LoginViewModel${ companion object { private const val TAG = "LoginViewModel" } private val _uiState = MutableStateFlow(LoginUiState()) val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow() private val _mainUiState = MutableStateFlow(MainUiState()) val mainUiState: StateFlow&lt;MainUiState&gt; = _mainUiState.asStateFlow() /** Check and restore login state from local storage */ fun checkLoginState() { viewModelScope.launch { val user = getLoginStateUseCase() _mainUiState.value = MainUiState(userPubkey = user?.pubkey) } } /** Handle login button click, checking NIP-55 signer installation status */ fun onLoginButtonClicked() { val isNip55SignerInstalled = loginUseCase.checkNip55SignerInstalled() if (!isNip55SignerInstalled) { _uiState.value = _uiState.value.copy(showNip55InstallDialog = true, errorMessage = null, isLoading = false) } } /** Handle logout button click, clearing login state */ fun onLogoutButtonClicked() { viewModelScope.launch { _mainUiState.value = _mainUiState.value.copy(isLoggingOut = true) val result = logoutUseCase() if (result.isSuccess) { _mainUiState.value = MainUiState(userPubkey = null, isLoggingOut = false) } else { _mainUiState.value = _mainUiState.value.copy(isLoggingOut = false) } } } /** Dismiss error dialog and reset error state */ fun dismissError() { _uiState.value = _uiState.value.copy( errorMessage = null, showNip55InstallDialog = false, loginSuccess = false) } /** Retry login after an error occurred */ fun onRetryLogin() { dismissError() onLoginButtonClicked() } /** * Process response after receiving ActivityResult from NIP-55 signer * * @param resultCode ActivityResult resultCode * @param data Intent data */ fun processNip55Response(resultCode: Int, data: Intent?) { viewModelScope.launch { _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null, loginSuccess = false) val result = authRepository.processNip55Response(resultCode, data) if (result.isSuccess) { val user = result.getOrNull() // Fetch NIP-65 relay list and wait for completion before login success val pubkey = user?.pubkey if (pubkey != null) { val relayResult = fetchRelayListUseCase(pubkey) if (relayResult.isFailure) { Log.w( TAG, "Failed to fetch NIP-65 relay list: ${relayResult.exceptionOrNull()?.message}") } } _mainUiState.value = MainUiState(userPubkey = user?.pubkey) _uiState.value = _uiState.value.copy(isLoading = false, loginSuccess = true, errorMessage = null) } else { val error = result.exceptionOrNull() val errorMessage = when (error) { is LoginError.UserRejected -&gt; "Login was cancelled. Please try again." is LoginError.Timeout -&gt; "Login process timed out. Please check the NIP-55 signer app and retry." is LoginError.NetworkError -&gt; "A network error occurred. Please check your connection." is LoginError.UnknownError -&gt; "An error occurred. Please try again later." else -&gt; "An error occurred. Please try again later." } _uiState.value = _uiState.value.copy( isLoading = false, errorMessage = errorMessage, loginSuccess = false) } } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LoginViewModelTest.kt$LoginViewModelTest${ private lateinit var loginUseCase: LoginUseCase private lateinit var logoutUseCase: LogoutUseCase private lateinit var getLoginStateUseCase: GetLoginStateUseCase private lateinit var authRepository: AuthRepository private lateinit var fetchRelayListUseCase: io.github.omochice.pinosu.domain.usecase.FetchRelayListUseCase private lateinit var viewModel: LoginViewModel private val testDispatcher = StandardTestDispatcher() @Before fun setup() { Dispatchers.setMain(testDispatcher) loginUseCase = mockk(relaxed = true) logoutUseCase = mockk(relaxed = true) getLoginStateUseCase = mockk(relaxed = true) authRepository = mockk(relaxed = true) fetchRelayListUseCase = mockk(relaxed = true) viewModel = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) } @After fun tearDown() { Dispatchers.resetMain() } @Test fun `initial LoginUiState should have default values`() = runTest { val state = viewModel.uiState.first() assertFalse("isLoading should be false", state.isLoading) assertNull("errorMessage should be null", state.errorMessage) assertFalse("showNip55InstallDialog should be false", state.showNip55InstallDialog) assertFalse("loginSuccess should be false", state.loginSuccess) } @Test fun `initial MainUiState should have default values`() = runTest { val state = viewModel.mainUiState.first() assertNull("userPubkey should be null", state.userPubkey) assertFalse("isLoggingOut should be false", state.isLoggingOut) } @Test fun `checkLoginState should update mainUiState when user is logged in`() = runTest { val testPubkey = "npub1" + "a".repeat(59) val testUser = User(testPubkey) coEvery { getLoginStateUseCase() } returns testUser viewModel.checkLoginState() advanceUntilIdle() val state = viewModel.mainUiState.first() assertEquals("userPubkey should be set", testPubkey, state.userPubkey) coVerify { getLoginStateUseCase() } } @Test fun `checkLoginState should keep mainUiState null when user is not logged in`() = runTest { coEvery { getLoginStateUseCase() } returns null viewModel.checkLoginState() advanceUntilIdle() val state = viewModel.mainUiState.first() assertNull("userPubkey should be null", state.userPubkey) coVerify { getLoginStateUseCase() } } @Test fun `onLoginButtonClicked should check if NIP-55 signer is installed`() = runTest { every { loginUseCase.checkNip55SignerInstalled() } returns true viewModel.onLoginButtonClicked() advanceUntilIdle() io.mockk.verify { loginUseCase.checkNip55SignerInstalled() } } @Test fun `onLoginButtonClicked should show install dialog when NIP-55 signer is not installed`() = runTest { every { loginUseCase.checkNip55SignerInstalled() } returns false viewModel.onLoginButtonClicked() advanceUntilIdle() val state = viewModel.uiState.first() assertTrue("showNip55InstallDialog should be true", state.showNip55InstallDialog) } @Test fun `onLogoutButtonClicked should call logoutUseCase and update state on success`() = runTest { coEvery { logoutUseCase() } returns Result.success(Unit) viewModel.onLogoutButtonClicked() advanceUntilIdle() coVerify { logoutUseCase() } val state = viewModel.mainUiState.first() assertNull("userPubkey should be null after logout", state.userPubkey) } @Test fun `onLogoutButtonClicked should handle logout failure gracefully`() = runTest { val error = io.github.omochice.pinosu.domain.model.error.LogoutError.StorageError("Failed") coEvery { logoutUseCase() } returns Result.failure(error) viewModel.onLogoutButtonClicked() advanceUntilIdle() coVerify { logoutUseCase() } val state = viewModel.mainUiState.first() assertFalse("isLoggingOut should be false after failure", state.isLoggingOut) } @Test fun `dismissError should clear error message`() = runTest { every { loginUseCase.checkNip55SignerInstalled() } returns false viewModel.onLoginButtonClicked() advanceUntilIdle() viewModel.dismissError() advanceUntilIdle() val state = viewModel.uiState.first() assertNull("errorMessage should be null", state.errorMessage) assertFalse("showNip55InstallDialog should be false", state.showNip55InstallDialog) } @Test fun `onRetryLogin should retry login by calling onLoginButtonClicked`() = runTest { every { loginUseCase.checkNip55SignerInstalled() } returns true viewModel.onRetryLogin() advanceUntilIdle() io.mockk.verify { loginUseCase.checkNip55SignerInstalled() } } @Test fun `processNip55Response should set loading state during processing`() = runTest { val testPubkey = "npub1" + "c".repeat(59) val testUser = User(testPubkey) val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() coEvery { authRepository.processNip55Response(any(), any()) } coAnswers { kotlinx.coroutines.delay(100) Result.success(testUser) } every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() coVerify { authRepository.processNip55Response(any(), any()) } } @Test fun `processNip55Response should set loginSuccess on success`() = runTest { val testPubkey = "npub1" + "d".repeat(59) val testUser = User(testPubkey) val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() coEvery { authRepository.processNip55Response(any(), any()) } returns Result.success(testUser) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() val loginState = viewModelWithMock.uiState.first() val mainState = viewModelWithMock.mainUiState.first() assertTrue("loginSuccess should be true", loginState.loginSuccess) assertFalse("isLoading should be false after success", loginState.isLoading) assertEquals("userPubkey should be set", testPubkey, mainState.userPubkey) } @Test fun `processNip55Response should set error message on UserRejected error`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() val error = io.github.omochice.pinosu.domain.model.error.LoginError.UserRejected coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModelWithMock.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("isLoading should be false", state.isLoading) assertFalse("loginSuccess should be false", state.loginSuccess) } @Test fun `processNip55Response should set error message on Timeout error`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() val error = io.github.omochice.pinosu.domain.model.error.LoginError.Timeout coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModelWithMock.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertTrue( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true) assertFalse("isLoading should be false", state.isLoading) } @Test fun `processNip55Response should handle NetworkError`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() val error = io.github.omochice.pinosu.domain.model.error.LoginError.NetworkError("Connection failed") coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModelWithMock.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("isLoading should be false", state.isLoading) } @Test fun `processNip55Response should wait for relay list fetch before setting loginSuccess`() = runTest { val testPubkey = "npub1" + "e".repeat(59) val testUser = User(testPubkey) val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() val fetchRelayListUseCase = mockk&lt;io.github.omochice.pinosu.domain.usecase.FetchRelayListUseCase&gt;() coEvery { authRepository.processNip55Response(any(), any()) } returns Result.success(testUser) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) coEvery { fetchRelayListUseCase(any()) } coAnswers { kotlinx.coroutines.delay(100) Result.success(emptyList()) } val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() coVerify { fetchRelayListUseCase(testPubkey) } val state = viewModelWithMock.uiState.first() assertTrue("loginSuccess should be true after relay fetch completes", state.loginSuccess) assertFalse("isLoading should be false", state.isLoading) } @Test fun `processNip55Response should succeed even if relay list fetch fails`() = runTest { val testPubkey = "npub1" + "f".repeat(59) val testUser = User(testPubkey) val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val authRepository = mockk&lt;io.github.omochice.pinosu.data.repository.AuthRepository&gt;() val fetchRelayListUseCase = mockk&lt;io.github.omochice.pinosu.domain.usecase.FetchRelayListUseCase&gt;() coEvery { authRepository.processNip55Response(any(), any()) } returns Result.success(testUser) every { authRepository.checkNip55SignerInstalled() } returns true coEvery { authRepository.getLoginState() } returns null coEvery { authRepository.logout() } returns Result.success(Unit) coEvery { fetchRelayListUseCase(any()) } returns Result.failure(RuntimeException("Network error")) val viewModelWithMock = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) viewModelWithMock.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModelWithMock.uiState.first() assertTrue("loginSuccess should be true even if relay fetch fails", state.loginSuccess) assertFalse("isLoading should be false", state.isLoading) assertNull( "errorMessage should be null (relay fetch failure is logged, not shown)", state.errorMessage) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:LogoutUseCase.kt$LogoutUseCase${ /** * Execute logout process * * Delegates to AuthRepository to clear login state from local storage. Guarantees idempotency and * processes normally even if already logged out. * * @return Success on success, Failure(LogoutError) on failure */ suspend operator fun invoke(): Result&lt;Unit&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:LogoutUseCaseTest.kt$LogoutUseCaseTest${ private lateinit var authRepository: AuthRepository private lateinit var logoutUseCase: LogoutUseCase @Before fun setup() { authRepository = mockk(relaxed = true) logoutUseCase = Nip55LogoutUseCase(authRepository) } @Test fun `invoke on success should return success`() = runTest { coEvery { authRepository.logout() } returns Result.success(Unit) val result = logoutUseCase() assertTrue("Should return success", result.isSuccess) coVerify { authRepository.logout() } } @Test fun `invoke on failure should return LogoutError`() = runTest { val error = LogoutError.StorageError("Failed to clear") coEvery { authRepository.logout() } returns Result.failure(error) val result = logoutUseCase() assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue( "Exception should be LogoutError.StorageError", exception is LogoutError.StorageError) coVerify { authRepository.logout() } } @Test fun `invoke multiple calls should succeed (idempotency)`() = runTest { coEvery { authRepository.logout() } returns Result.success(Unit) val result1 = logoutUseCase() val result2 = logoutUseCase() assertTrue("First call should succeed", result1.isSuccess) assertTrue("Second call should succeed", result2.isSuccess) coVerify(exactly = 2) { authRepository.logout() } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:MainActivityTest.kt$MainActivityTest${ @Test fun `when logged in on startup, should show main screen`() = runTest { val mockGetLoginStateUseCase = mockk&lt;GetLoginStateUseCase&gt;() val loggedInUser = User("npub1" + "1234567890abcdef".repeat(3) + "1234567890a") coEvery { mockGetLoginStateUseCase() } returns loggedInUser val initialDestination = determineInitialDestination(mockGetLoginStateUseCase) assertEquals("MainScreen", initialDestination) } @Test fun `when not logged in on startup, should show login screen`() = runTest { val mockGetLoginStateUseCase = mockk&lt;GetLoginStateUseCase&gt;() coEvery { mockGetLoginStateUseCase() } returns null val initialDestination = determineInitialDestination(mockGetLoginStateUseCase) assertEquals("LoginScreen", initialDestination) } @Test fun `when invalid data detected on startup, should show login screen`() = runTest { val mockGetLoginStateUseCase = mockk&lt;GetLoginStateUseCase&gt;() coEvery { mockGetLoginStateUseCase() } returns null val initialDestination = determineInitialDestination(mockGetLoginStateUseCase) assertEquals("LoginScreen", initialDestination) } /** * Determine initial display screen based on login state * * Helper function to test logic planned for MainActivity */ private suspend fun determineInitialDestination( getLoginStateUseCase: GetLoginStateUseCase ): String { val user = getLoginStateUseCase() return if (user != null) "MainScreen" else "LoginScreen" } }</ID>
    <ID>NoEmptyFirstLineInClassBody:NetworkModule.kt$NetworkModule${ @Provides @Singleton fun provideOkHttpClient(): OkHttpClient { return OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(10, TimeUnit.SECONDS) .build() } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55AuthRepository.kt$Nip55AuthRepository${ /** * Get login state * * @return User if logged in, null if not logged in */ override suspend fun getLoginState(): User? { return localAuthDataSource.getUser() } /** * Save login state * * @param user User to save * @return Success on success, Failure(StorageError) on failure */ override suspend fun saveLoginState(user: User): Result&lt;Unit&gt; { return try { localAuthDataSource.saveUser(user) Result.success(Unit) } catch (e: StorageError) { Result.failure(e) } } /** * Logout * * @return Success on success, Failure(LogoutError) on failure */ override suspend fun logout(): Result&lt;Unit&gt; { return try { localAuthDataSource.clearLoginState() Result.success(Unit) } catch (e: StorageError) { Result.failure(LogoutError.StorageError(e.message ?: "Failed to clear login state")) } } /** * Process NIP-55 signer response and set user to logged-in state * * @param resultCode ActivityResult's resultCode * @param data Intent data * @return Success(User) on success, Failure(LoginError) on failure */ override suspend fun processNip55Response(resultCode: Int, data: Intent?): Result&lt;User&gt; { val nip55Result = nip55SignerClient.handleNip55Response(resultCode, data) return if (nip55Result.isSuccess) { val nip55Response = nip55Result.getOrNull()!! val user = User(nip55Response.pubkey) try { localAuthDataSource.saveUser(user) Result.success(user) } catch (e: StorageError) { Result.failure(LoginError.UnknownError(e)) } } else { val nip55Error = nip55Result.exceptionOrNull() as? Nip55Error val loginError = when (nip55Error) { is Nip55Error.NotInstalled -&gt; LoginError.Nip55SignerNotInstalled is Nip55Error.UserRejected -&gt; LoginError.UserRejected is Nip55Error.Timeout -&gt; LoginError.Timeout is Nip55Error.InvalidResponse, is Nip55Error.IntentResolutionError -&gt; LoginError.NetworkError(nip55Error?.toString() ?: "Unknown NIP-55 signer error") null -&gt; LoginError.UnknownError(Exception("Unknown NIP-55 signer error")) } Result.failure(loginError) } } /** * Check if NIP-55 signer app is installed * * @return true if NIP-55 signer is installed */ override fun checkNip55SignerInstalled(): Boolean { return nip55SignerClient.checkNip55SignerInstalled() } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest${ private lateinit var nip55SignerClient: Nip55SignerClient private lateinit var localAuthDataSource: LocalAuthDataSource private lateinit var authRepository: AuthRepository @Before fun setup() { nip55SignerClient = mockk(relaxed = true) localAuthDataSource = mockk(relaxed = true) authRepository = Nip55AuthRepository(nip55SignerClient, localAuthDataSource) } @Test fun `getLoginState when user exists should return user`() = runTest { val expectedUser = User("npub1" + "a".repeat(59)) coEvery { localAuthDataSource.getUser() } returns expectedUser val result = authRepository.getLoginState() assertEquals("Should return user from LocalAuthDataSource", expectedUser, result) coVerify { localAuthDataSource.getUser() } } @Test fun `getLoginState when no user should return null`() = runTest { coEvery { localAuthDataSource.getUser() } returns null val result = authRepository.getLoginState() assertNull("Should return null when no user is stored", result) coVerify { localAuthDataSource.getUser() } } @Test fun `saveLoginState on success should return success`() = runTest { val user = User("npub1" + "a".repeat(59)) coEvery { localAuthDataSource.saveUser(user) } returns Unit val result = authRepository.saveLoginState(user) assertTrue("Should return success", result.isSuccess) coVerify { localAuthDataSource.saveUser(user) } } @Test fun `saveLoginState on failure should return StorageError`() = runTest { val user = User("npub1" + "a".repeat(59)) val storageError = StorageError.WriteError("Failed to save") coEvery { localAuthDataSource.saveUser(user) } throws storageError val result = authRepository.saveLoginState(user) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue("Exception should be StorageError", exception is StorageError.WriteError) coVerify { localAuthDataSource.saveUser(user) } } @Test fun `logout on success should return success`() = runTest { coEvery { localAuthDataSource.clearLoginState() } returns Unit val result = authRepository.logout() assertTrue("Should return success", result.isSuccess) coVerify { localAuthDataSource.clearLoginState() } } @Test fun `logout on failure should return LogoutError`() = runTest { val storageError = StorageError.WriteError("Failed to clear") coEvery { localAuthDataSource.clearLoginState() } throws storageError val result = authRepository.logout() assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue( "Exception should be LogoutError.StorageError", exception is LogoutError.StorageError) coVerify { localAuthDataSource.clearLoginState() } } @Test fun `processNip55Response on success should save user and return success`() = runTest { val pubkey = "npub1" + "a".repeat(59) val intent = Intent().apply { putExtra("result", pubkey) } val nip55Response = Nip55Response(pubkey, Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME) every { nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) } returns Result.success(nip55Response) coEvery { localAuthDataSource.saveUser(any()) } returns Unit val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return success", result.isSuccess) val user = result.getOrNull() assertNotNull("User should not be null", user) assertEquals("Pubkey should match", pubkey, user?.pubkey) coVerify { localAuthDataSource.saveUser(any()) } } @Test fun `processNip55Response when user rejected should return LoginError`() = runTest { val intent = Intent().apply { putExtra("rejected", true) } every { nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) } returns Result.failure(io.github.omochice.pinosu.data.nip55.Nip55Error.UserRejected) val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue("Exception should be LoginError.UserRejected", exception is LoginError.UserRejected) } @Test fun `processNip55Response when Nip55Signer not installed should return Nip55SignerNotInstalledError`() = runTest { val intent = Intent() every { nip55SignerClient.handleNip55Response(any(), any()) } returns Result.failure(io.github.omochice.pinosu.data.nip55.Nip55Error.NotInstalled) val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue( "Exception should be LoginError.Nip55SignerNotInstalled", exception is LoginError.Nip55SignerNotInstalled) } @Test fun `processNip55Response on timeout should return TimeoutError`() = runTest { val intent = Intent() every { nip55SignerClient.handleNip55Response(any(), any()) } returns Result.failure(io.github.omochice.pinosu.data.nip55.Nip55Error.Timeout) val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue("Exception should be LoginError.Timeout", exception is LoginError.Timeout) } @Test fun `processNip55Response on InvalidResponse should return NetworkError`() = runTest { val intent = Intent() every { nip55SignerClient.handleNip55Response(any(), any()) } returns Result.failure( io.github.omochice.pinosu.data.nip55.Nip55Error.InvalidResponse("Invalid data")) val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue("Exception should be LoginError.NetworkError", exception is LoginError.NetworkError) } @Test fun `processNip55Response when Nip55Signer success but local storage fails should return UnknownError`() = runTest { val pubkey = "npub1" + "a".repeat(59) val intent = Intent().apply { putExtra("result", pubkey) } val nip55Response = Nip55Response(pubkey, Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME) every { nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) } returns Result.success(nip55Response) coEvery { localAuthDataSource.saveUser(any()) } throws StorageError.WriteError("Storage full") val result = authRepository.processNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val exception = result.exceptionOrNull() assertTrue( "Exception should be LoginError.UnknownError", exception is LoginError.UnknownError) val unknownError = exception as LoginError.UnknownError assertTrue( "Cause should be StorageError", unknownError.throwable is StorageError.WriteError) } @Test fun `checkNip55SignerInstalled when installed should return true`() { every { nip55SignerClient.checkNip55SignerInstalled() } returns true val result = authRepository.checkNip55SignerInstalled() assertTrue("Should return true when NIP-55 signer is installed", result) } @Test fun `checkNip55SignerInstalled when not installed should return false`() { every { nip55SignerClient.checkNip55SignerInstalled() } returns false val result = authRepository.checkNip55SignerInstalled() assertFalse("Should return false when NIP-55 signer is not installed", result) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55GetLoginStateUseCase.kt$Nip55GetLoginStateUseCase${ /** * Get the login state * * @return User if logged in, null if not logged in */ override suspend fun invoke(): User? { return authRepository.getLoginState() } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55LoginUseCase.kt$Nip55LoginUseCase${ /** * Check if the NIP-55 signer app is installed * * @return true if NIP-55 signer is installed */ override fun checkNip55SignerInstalled(): Boolean { return authRepository.checkNip55SignerInstalled() } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55LogoutUseCase.kt$Nip55LogoutUseCase${ /** * Execute logout process * * @return Success on success, Failure(LogoutError) on failure */ override suspend fun invoke(): Result&lt;Unit&gt; { return authRepository.logout() } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55SignerClient.kt$Nip55SignerClient${ /** * Check if NIP-55 signer app is installed * * @return true if NIP-55 signer is installed, false otherwise */ fun checkNip55SignerInstalled(): Boolean { return try { context.packageManager.getPackageInfo( NIP55_SIGNER_PACKAGE_NAME, PackageManager.GET_ACTIVITIES) true } catch (e: PackageManager.NameNotFoundException) { false } catch (e: Exception) { false } } /** * Create Intent for NIP-55 public key retrieval request * * @return Constructed Intent */ fun createPublicKeyIntent(): Intent { val intent = Intent(Intent.ACTION_VIEW, Uri.parse("$NOSTRSIGNER_SCHEME:")) intent.`package` = NIP55_SIGNER_PACKAGE_NAME intent.putExtra("type", TYPE_GET_PUBLIC_KEY) intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP) return intent } /** * Handle ActivityResult response from NIP-55 signer * * @param resultCode ActivityResult's resultCode (RESULT_OK or RESULT_CANCELED) * @param data Intent data (containing result and rejected) * @return Success(Nip55Response) or Failure(Nip55Error) */ fun handleNip55Response(resultCode: Int, data: Intent?): Result&lt;Nip55Response&gt; { if (resultCode == Activity.RESULT_CANCELED) { return Result.failure(Nip55Error.UserRejected) } if (data == null) { return Result.failure(Nip55Error.InvalidResponse("Intent data is null")) } val rejected = data.getBooleanExtra("rejected", false) if (rejected) { return Result.failure(Nip55Error.UserRejected) } val pubkey = data.getStringExtra("result") if (pubkey.isNullOrEmpty()) { return Result.failure(Nip55Error.InvalidResponse("Result is null or empty")) } if (!pubkey.isValidNostrPubkey()) { return Result.failure( Nip55Error.InvalidResponse("Invalid pubkey format: must be Bech32-encoded (npub1...)")) } return Result.success(Nip55Response(pubkey, NIP55_SIGNER_PACKAGE_NAME)) } /** * Mask sensitive pubkey for logging * * @param pubkey pubkey string to mask * @return Masked pubkey string (e.g., "abcd1234...wxyz7890") */ fun maskPubkey(pubkey: String): String { if (pubkey.isEmpty()) { return pubkey } // Reason: masking result would be 19 characters (8+3+8), which increases information for // strings 16 chars or less if (pubkey.length &lt;= 16) { return pubkey } val prefix = pubkey.take(8) val suffix = pubkey.takeLast(8) return "$prefix...$suffix" } /** * Create Intent for NIP-55 event signing request * * @param unsignedEventJson JSON string of the unsigned event * @return Constructed Intent for signing */ fun createSignEventIntent(unsignedEventJson: String): Intent { val intent = Intent(Intent.ACTION_VIEW, Uri.parse("$NOSTRSIGNER_SCHEME:$unsignedEventJson")) intent.`package` = NIP55_SIGNER_PACKAGE_NAME intent.putExtra("type", TYPE_SIGN_EVENT) intent.putExtra("returnType", RETURN_TYPE_EVENT) intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP) return intent } /** * Handle ActivityResult response from NIP-55 signer for sign event * * @param resultCode ActivityResult's resultCode (RESULT_OK or RESULT_CANCELED) * @param data Intent data (containing signature) * @return Success(SignedEventResponse) or Failure(Nip55Error) */ fun handleSignEventResponse(resultCode: Int, data: Intent?): Result&lt;SignedEventResponse&gt; { if (resultCode == Activity.RESULT_CANCELED) { return Result.failure(Nip55Error.UserRejected) } if (data == null) { return Result.failure(Nip55Error.InvalidResponse("Intent data is null")) } val rejected = data.getBooleanExtra("rejected", false) if (rejected) { return Result.failure(Nip55Error.UserRejected) } val signedEventJson = data.getStringExtra("result") Log.d(TAG, "Sign event response: $signedEventJson") if (signedEventJson.isNullOrEmpty()) { return Result.failure(Nip55Error.InvalidResponse("Signed event result is null or empty")) } return Result.success(SignedEventResponse(signedEventJson)) } companion object { private const val TAG = "Nip55SignerClient" const val NIP55_SIGNER_PACKAGE_NAME = "com.greenart7c3.nostrsigner" const val NOSTRSIGNER_SCHEME = "nostrsigner" const val TYPE_GET_PUBLIC_KEY = "get_public_key" const val TYPE_SIGN_EVENT = "sign_event" const val RETURN_TYPE_EVENT = "event" } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip55SignerClientTest.kt$Nip55SignerClientTest${ private lateinit var context: Context private lateinit var packageManager: PackageManager private lateinit var nip55SignerClient: Nip55SignerClient @Before fun setup() { context = mockk(relaxed = true) packageManager = mockk(relaxed = true) every { context.packageManager } returns packageManager nip55SignerClient = Nip55SignerClient(context) } @Test fun `checkNip55SignerInstalled when installed should return true`() { every { packageManager.getPackageInfo( Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, PackageManager.GET_ACTIVITIES) } returns android.content.pm.PackageInfo() val result = nip55SignerClient.checkNip55SignerInstalled() assertTrue("Should return true when NIP-55 signer is installed", result) } @Test fun `checkNip55SignerInstalled when not installed should return false`() { every { packageManager.getPackageInfo( Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, PackageManager.GET_ACTIVITIES) } throws PackageManager.NameNotFoundException() val result = nip55SignerClient.checkNip55SignerInstalled() assertFalse("Should return false when NIP-55 signer is not installed", result) } @Test fun `checkNip55SignerInstalled on exception should return false`() { every { packageManager.getPackageInfo( Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, PackageManager.GET_ACTIVITIES) } throws RuntimeException("Unexpected error") val result = nip55SignerClient.checkNip55SignerInstalled() assertFalse("Should return false on exception", result) } @Test fun `createPublicKeyIntent should have correct scheme`() { val intent = nip55SignerClient.createPublicKeyIntent() assertNotNull("Intent should have data URI", intent.data) assertEquals( "URI scheme should be nostrsigner", Nip55SignerClient.NOSTRSIGNER_SCHEME, intent.data?.scheme) } @Test fun `createPublicKeyIntent should have correct package`() { val intent = nip55SignerClient.createPublicKeyIntent() assertEquals( "Package should be NIP-55 signer package name", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, intent.`package`) } @Test fun `createPublicKeyIntent should have correct type`() { val intent = nip55SignerClient.createPublicKeyIntent() assertEquals( "Type extra should be get_public_key", Nip55SignerClient.TYPE_GET_PUBLIC_KEY, intent.getStringExtra("type")) } @Test fun `createPublicKeyIntent should have correct flags`() { val intent = nip55SignerClient.createPublicKeyIntent() val expectedFlags = android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP or android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP assertTrue( "Intent should have SINGLE_TOP and CLEAR_TOP flags", (intent.flags and expectedFlags) == expectedFlags) } @Test fun `createPublicKeyIntent should have correct action`() { val intent = nip55SignerClient.createPublicKeyIntent() assertEquals( "Intent action should be ACTION_VIEW", android.content.Intent.ACTION_VIEW, intent.action) } @Test fun `handleNip55Response on success should return Nip55Response`() { val pubkey = "npub1" + "a".repeat(59) val intent = android.content.Intent() intent.putExtra("result", pubkey) val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return success", result.isSuccess) val response = result.getOrNull() assertNotNull("Response should not be null", response) assertEquals("Pubkey should match", pubkey, response?.pubkey) assertEquals( "PackageName should be NIP-55 signer package", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, response?.packageName) } @Test fun `handleNip55Response when user rejected should return error`() { val intent = android.content.Intent() intent.putExtra("rejected", true) val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be UserRejected", error is Nip55Error.UserRejected || error.toString().contains("UserRejected")) } @Test fun `handleNip55Response when result canceled should return UserRejected`() { val intent = android.content.Intent() val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_CANCELED, intent) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be UserRejected", error is Nip55Error.UserRejected || error.toString().contains("UserRejected")) } @Test fun `handleNip55Response with null intent should return InvalidResponse`() { val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, null) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse")) } @Test fun `handleNip55Response with empty result should return InvalidResponse`() { val intent = android.content.Intent() intent.putExtra("result", "") val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse")) } @Test fun `handleNip55Response with invalid pubkey length should return InvalidResponse`() { val intent = android.content.Intent() intent.putExtra("result", "a".repeat(64)) val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse")) } @Test fun `handleNip55Response with invalid pubkey format should return InvalidResponse`() { val intent = android.content.Intent() intent.putExtra("result", "nsec1" + "a".repeat(59)) val result = nip55SignerClient.handleNip55Response(android.app.Activity.RESULT_OK, intent) assertTrue("Should return failure", result.isFailure) val error = result.exceptionOrNull() assertTrue( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse")) } @Test fun `maskPubkey with valid pubkey should return masked string`() { val pubkey = "npub1" + "abcdef0123456789".repeat(3) + "abcdef01234" val masked = nip55SignerClient.maskPubkey(pubkey) assertEquals("Should mask pubkey as first8...last8", "npub1abc...def01234", masked) } @Test fun `maskPubkey with different pubkey should return masked string`() { val pubkey = "npub1" + "1234567890abcdef".repeat(3) + "1234567890a" val masked = nip55SignerClient.maskPubkey(pubkey) assertEquals("Should mask pubkey as first8...last8", "npub1123...4567890a", masked) } @Test fun `maskPubkey with short pubkey should return original string`() { val pubkey = "abcdef0123456789" val masked = nip55SignerClient.maskPubkey(pubkey) assertEquals("Should return original string when pubkey is too short", pubkey, masked) } @Test fun `maskPubkey with empty string should return empty string`() { val pubkey = "" val masked = nip55SignerClient.maskPubkey(pubkey) assertEquals("Should return empty string when input is empty", "", masked) } @Test fun `maskPubkey result length should be correct`() { val pubkey = "npub1" + "a".repeat(59) val masked = nip55SignerClient.maskPubkey(pubkey) assertEquals("Masked string should be 19 characters (8+3+8)", 19, masked.length) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65EventParser.kt$Nip65EventParser${ /** * Parse a NIP-65 relay list event into a list of relay configurations * * @param event The NostrEvent to parse (expected kind 10002) * @return List of RelayConfig extracted from "r" tags. Empty list if event is invalid or has no * valid relays. */ fun parseRelayListEvent(event: NostrEvent): List&lt;RelayConfig&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65EventParser.kt$Nip65EventParserImpl${ companion object { /** NIP-65 Relay List Metadata event kind */ const val KIND_RELAY_LIST_METADATA = 10002 private const val TAG_RELAY = "r" private const val MARKER_READ = "read" private const val MARKER_WRITE = "write" } override fun parseRelayListEvent(event: NostrEvent): List&lt;RelayConfig&gt; { if (event.kind != KIND_RELAY_LIST_METADATA) { return emptyList() } return event.tags .filter { tag -&gt; tag.size &gt;= 2 &amp;&amp; tag[0] == TAG_RELAY } .mapNotNull { tag -&gt; parseRelayTag(tag) } } /** * Parse a single "r" tag into RelayConfig * * Tag format: ["r", "&lt;url&gt;", "&lt;optional marker&gt;"] where marker is "read" or "write". No marker * means both read and write are true. */ private fun parseRelayTag(tag: List&lt;String&gt;): RelayConfig? { val url = tag[1] if (!isValidRelayUrl(url)) { return null } val marker = tag.getOrNull(2) val (read, write) = when (marker) { MARKER_READ -&gt; Pair(true, false) MARKER_WRITE -&gt; Pair(false, true) else -&gt; Pair(true, true) } return RelayConfig(url = url, read = read, write = write) } /** Validate relay URL has WebSocket scheme (wss:// or ws://) */ private fun isValidRelayUrl(url: String): Boolean { return url.startsWith("wss://") || url.startsWith("ws://") } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65EventParserTest.kt$Nip65EventParserTest${ private lateinit var parser: Nip65EventParser @Before fun setup() { parser = Nip65EventParserImpl() } @Test fun `parseRelayListEvent with no marker should return relay with both read and write true`() { val event = createNip65Event(listOf(listOf("r", "wss://relay.example.com"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return one relay", 1, result.size) val relay = result.first() assertEquals("URL should match", "wss://relay.example.com", relay.url) assertTrue("read should be true when no marker", relay.read) assertTrue("write should be true when no marker", relay.write) } @Test fun `parseRelayListEvent with read marker should return relay with read true and write false`() { val event = createNip65Event(listOf(listOf("r", "wss://read-relay.example.com", "read"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return one relay", 1, result.size) val relay = result.first() assertEquals("URL should match", "wss://read-relay.example.com", relay.url) assertTrue("read should be true for read marker", relay.read) assertEquals("write should be false for read marker", false, relay.write) } @Test fun `parseRelayListEvent with write marker should return relay with read false and write true`() { val event = createNip65Event(listOf(listOf("r", "wss://write-relay.example.com", "write"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return one relay", 1, result.size) val relay = result.first() assertEquals("URL should match", "wss://write-relay.example.com", relay.url) assertEquals("read should be false for write marker", false, relay.read) assertTrue("write should be true for write marker", relay.write) } @Test fun `parseRelayListEvent with multiple relays should return all relays`() { val event = createNip65Event( listOf( listOf("r", "wss://relay1.example.com"), listOf("r", "wss://relay2.example.com", "read"), listOf("r", "wss://relay3.example.com", "write"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return three relays", 3, result.size) val relay1 = result.find { it.url == "wss://relay1.example.com" }!! assertTrue("relay1 should have read=true", relay1.read) assertTrue("relay1 should have write=true", relay1.write) val relay2 = result.find { it.url == "wss://relay2.example.com" }!! assertTrue("relay2 should have read=true", relay2.read) assertEquals("relay2 should have write=false", false, relay2.write) val relay3 = result.find { it.url == "wss://relay3.example.com" }!! assertEquals("relay3 should have read=false", false, relay3.read) assertTrue("relay3 should have write=true", relay3.write) } @Test fun `parseRelayListEvent with empty tags should return empty list`() { val event = createNip65Event(emptyList()) val result = parser.parseRelayListEvent(event) assertTrue("Should return empty list for empty tags", result.isEmpty()) } @Test fun `parseRelayListEvent with non-r tags should ignore them`() { val event = createNip65Event( listOf( listOf("r", "wss://relay.example.com"), listOf("p", "pubkey123"), listOf("e", "eventid456"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return only r tag relay", 1, result.size) assertEquals("URL should match r tag", "wss://relay.example.com", result.first().url) } @Test fun `parseRelayListEvent with wrong kind should return empty list`() { val event = NostrEvent( id = "test-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 1, // Wrong kind, should be 10002 tags = listOf(listOf("r", "wss://relay.example.com")), content = "") val result = parser.parseRelayListEvent(event) assertTrue("Should return empty list for wrong kind", result.isEmpty()) } @Test fun `parseRelayListEvent with malformed r tag missing url should skip it`() { val event = createNip65Event( listOf( listOf("r"), // Missing URL listOf("r", "wss://valid-relay.example.com"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return only valid relay", 1, result.size) assertEquals("URL should be the valid one", "wss://valid-relay.example.com", result.first().url) } @Test fun `parseRelayListEvent with invalid url scheme should skip it`() { val event = createNip65Event( listOf( listOf("r", "http://not-websocket.example.com"), listOf("r", "wss://valid-relay.example.com"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return only valid wss relay", 1, result.size) assertEquals( "URL should be the valid wss one", "wss://valid-relay.example.com", result.first().url) } @Test fun `parseRelayListEvent with unknown marker should treat as both read and write`() { val event = createNip65Event(listOf(listOf("r", "wss://relay.example.com", "unknown"))) val result = parser.parseRelayListEvent(event) assertEquals("Should return one relay", 1, result.size) val relay = result.first() assertTrue("read should be true for unknown marker", relay.read) assertTrue("write should be true for unknown marker", relay.write) } private fun createNip65Event(tags: List&lt;List&lt;String&gt;&gt;): NostrEvent { return NostrEvent( id = "test-event-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 10002, tags = tags, content = "") } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65RelayListFetcher.kt$Nip65RelayListFetcher${ /** * Fetch relay list for a given public key from Nostr relays * * @param hexPubkey 64-character hex-encoded public key * @return Success(List&lt;RelayConfig&gt;) with the parsed relay list, or empty list if not found. * Failure if pubkey is invalid or network error occurs. */ suspend fun fetchRelayList(hexPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl${ companion object { /** Bootstrap relay URL used to fetch NIP-65 events */ const val BOOTSTRAP_RELAY_URL = "wss://yabu.me" /** Timeout for relay queries in milliseconds */ const val RELAY_TIMEOUT_MS = 10000L /** Expected length of hex-encoded public key */ private const val HEX_PUBKEY_LENGTH = 64 /** Valid hex characters */ private val HEX_CHARS = "0123456789abcdefABCDEF".toSet() } override suspend fun fetchRelayList(hexPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt; { if (!isValidHexPubkey(hexPubkey)) { return Result.failure( IllegalArgumentException("Invalid hex pubkey: must be 64 hex characters")) } return try { val bootstrapRelays = listOf(RelayConfig(url = BOOTSTRAP_RELAY_URL)) val filter = """{"kinds":[${Nip65EventParserImpl.KIND_RELAY_LIST_METADATA}],"authors":["$hexPubkey"],"limit":1}""" val events = relayPool.subscribeWithTimeout(bootstrapRelays, filter, RELAY_TIMEOUT_MS) if (events.isEmpty()) { return Result.success(emptyList()) } val mostRecentEvent = events.maxByOrNull { it.createdAt } ?: return Result.success(emptyList()) val relays = parser.parseRelayListEvent(mostRecentEvent) Result.success(relays) } catch (e: Exception) { Result.failure(e) } } /** Validate that the pubkey is a valid 64-character hex string */ private fun isValidHexPubkey(pubkey: String): Boolean { return pubkey.length == HEX_PUBKEY_LENGTH &amp;&amp; pubkey.all { it in HEX_CHARS } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest${ private lateinit var relayPool: RelayPool private lateinit var parser: Nip65EventParser private lateinit var fetcher: Nip65RelayListFetcher @Before fun setup() { relayPool = mockk(relaxed = true) parser = Nip65EventParserImpl() fetcher = Nip65RelayListFetcherImpl(relayPool, parser) } @Test fun `fetchRelayList should return parsed relay list on successful fetch`() = runTest { val hexPubkey = "a".repeat(64) val nip65Event = createNip65Event(hexPubkey, listOf(listOf("r", "wss://relay.example.com"))) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } returns listOf(nip65Event) val result = fetcher.fetchRelayList(hexPubkey) assertTrue("Should return success", result.isSuccess) val relays = result.getOrNull()!! assertEquals("Should return one relay", 1, relays.size) assertEquals("Relay URL should match", "wss://relay.example.com", relays.first().url) } @Test fun `fetchRelayList should return empty list when no events found`() = runTest { val hexPubkey = "a".repeat(64) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } returns emptyList() val result = fetcher.fetchRelayList(hexPubkey) assertTrue("Should return success", result.isSuccess) assertTrue("Should return empty list", result.getOrNull()!!.isEmpty()) } @Test fun `fetchRelayList should use most recent event when multiple events returned`() = runTest { val hexPubkey = "a".repeat(64) val olderEvent = createNip65Event( hexPubkey, listOf(listOf("r", "wss://old-relay.example.com")), createdAt = 1000L) val newerEvent = createNip65Event( hexPubkey, listOf(listOf("r", "wss://new-relay.example.com")), createdAt = 2000L) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } returns listOf(olderEvent, newerEvent) val result = fetcher.fetchRelayList(hexPubkey) assertTrue("Should return success", result.isSuccess) val relays = result.getOrNull()!! assertEquals("Should return one relay from newer event", 1, relays.size) assertEquals( "Should use relay from newer event", "wss://new-relay.example.com", relays.first().url) } @Test fun `fetchRelayList should use correct filter for kind 10002`() = runTest { val hexPubkey = "abcd1234".repeat(8) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } returns emptyList() fetcher.fetchRelayList(hexPubkey) coVerify { relayPool.subscribeWithTimeout( any(), match { it.contains("\"kinds\":[10002]") &amp;&amp; it.contains("\"authors\":[\"$hexPubkey\"]") }, any()) } } @Test fun `fetchRelayList should use bootstrap relay for query`() = runTest { val hexPubkey = "a".repeat(64) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } returns emptyList() fetcher.fetchRelayList(hexPubkey) coVerify { relayPool.subscribeWithTimeout( match { relays -&gt; relays.any { it.url == "wss://yabu.me" } }, any(), any()) } } @Test fun `fetchRelayList should return failure for invalid hex pubkey`() = runTest { val invalidHexPubkey = "not-a-valid-hex" val result = fetcher.fetchRelayList(invalidHexPubkey) assertTrue("Should return failure for invalid pubkey", result.isFailure) } @Test fun `fetchRelayList should return failure for wrong length pubkey`() = runTest { val shortPubkey = "abcd1234" val result = fetcher.fetchRelayList(shortPubkey) assertTrue("Should return failure for short pubkey", result.isFailure) } @Test fun `fetchRelayList should handle relay pool exception gracefully`() = runTest { val hexPubkey = "a".repeat(64) coEvery { relayPool.subscribeWithTimeout(any(), any(), any()) } throws RuntimeException("Network error") val result = fetcher.fetchRelayList(hexPubkey) assertTrue("Should return failure on exception", result.isFailure) assertTrue( "Exception message should be preserved", result.exceptionOrNull()?.message?.contains("Network error") == true) } private fun createNip65Event( pubkey: String, tags: List&lt;List&lt;String&gt;&gt;, createdAt: Long = 1234567890L ): NostrEvent { return NostrEvent( id = "test-event-id-${createdAt}", pubkey = pubkey, createdAt = createdAt, kind = 10002, tags = tags, content = "") } }</ID>
    <ID>NoEmptyFirstLineInClassBody:PostBookmarkUseCase.kt$PostBookmarkUseCase${ /** * Create an unsigned bookmark event * * @param url URL to bookmark (without scheme) * @param title Bookmark title * @param categories List of categories * @param comment Bookmark comment * @return Result containing unsigned event on success or error on failure */ suspend fun createUnsignedEvent( url: String, title: String, categories: List&lt;String&gt;, comment: String ): Result&lt;UnsignedNostrEvent&gt; /** * Publish a signed bookmark event to relays * * @param signedEventJson Signed event as JSON string * @return Result containing PublishResult on success or error on failure */ suspend fun publishSignedEvent(signedEventJson: String): Result&lt;PublishResult&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl${ override suspend fun createUnsignedEvent( url: String, title: String, categories: List&lt;String&gt;, comment: String ): Result&lt;UnsignedNostrEvent&gt; { val user = getLoginStateUseCase() if (user == null) { return Result.failure(IllegalStateException("User not logged in")) } val hexPubkey = Bech32.npubToHex(user.pubkey) ?: return Result.failure(IllegalArgumentException("Invalid npub format")) return Result.success( bookmarkRepository.createBookmarkEvent( hexPubkey = hexPubkey, url = url, title = title, categories = categories, comment = comment)) } override suspend fun publishSignedEvent(signedEventJson: String): Result&lt;PublishResult&gt; { return bookmarkRepository.publishBookmark(signedEventJson) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest${ private lateinit var bookmarkRepository: BookmarkRepository private lateinit var getLoginStateUseCase: GetLoginStateUseCase private lateinit var postBookmarkUseCase: PostBookmarkUseCase @Before fun setup() { bookmarkRepository = mockk() getLoginStateUseCase = mockk() postBookmarkUseCase = PostBookmarkUseCaseImpl(bookmarkRepository, getLoginStateUseCase) } @Test fun `createUnsignedEvent returns failure when user not logged in`() = runTest { coEvery { getLoginStateUseCase() } returns null val result = postBookmarkUseCase.createUnsignedEvent( url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article") assertTrue(result.isFailure) val exception = result.exceptionOrNull() assertNotNull(exception) assertTrue(exception is IllegalStateException) assertEquals("User not logged in", exception?.message) } @Test fun `createUnsignedEvent returns failure when npub format is invalid`() = runTest { val mockUser = mockk&lt;User&gt;() every { mockUser.pubkey } returns "invalid_npub_format" coEvery { getLoginStateUseCase() } returns mockUser val result = postBookmarkUseCase.createUnsignedEvent( url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article") assertTrue(result.isFailure) val exception = result.exceptionOrNull() assertNotNull(exception) assertTrue(exception is IllegalArgumentException) } @Test fun `createUnsignedEvent returns success with valid user`() = runTest { val validNpub = "npub1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq4hl3lg" val hexPubkey = "0000000000000000000000000000000000000000000000000000000000000000" val expectedEvent = UnsignedNostrEvent( pubkey = hexPubkey, createdAt = 1234567890L, kind = 39701, tags = listOf(listOf("r", "https://example.com/article")), content = "Great article") coEvery { getLoginStateUseCase() } returns User(validNpub) coEvery { bookmarkRepository.createBookmarkEvent( hexPubkey = any(), url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article") } returns expectedEvent val result = postBookmarkUseCase.createUnsignedEvent( url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article") assertTrue(result.isSuccess) assertEquals(expectedEvent, result.getOrNull()) coVerify(exactly = 1) { getLoginStateUseCase() } coVerify(exactly = 1) { bookmarkRepository.createBookmarkEvent( hexPubkey = any(), url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article") } } @Test fun `publishSignedEvent delegates to repository`() = runTest { val signedEventJson = """{"id":"abc123","sig":"def456"}""" val expectedResult = PublishResult( eventId = "abc123", successfulRelays = listOf("wss://relay1.example.com"), failedRelays = emptyList()) coEvery { bookmarkRepository.publishBookmark(signedEventJson) } returns Result.success(expectedResult) val result = postBookmarkUseCase.publishSignedEvent(signedEventJson) assertTrue(result.isSuccess) assertEquals(expectedResult, result.getOrNull()) coVerify(exactly = 1) { bookmarkRepository.publishBookmark(signedEventJson) } } @Test fun `publishSignedEvent returns failure when repository fails`() = runTest { val signedEventJson = """{"id":"abc123","sig":"def456"}""" val expectedException = Exception("Failed to publish to any relay") coEvery { bookmarkRepository.publishBookmark(signedEventJson) } returns Result.failure(expectedException) val result = postBookmarkUseCase.publishSignedEvent(signedEventJson) assertTrue(result.isFailure) assertEquals(expectedException, result.exceptionOrNull()) coVerify(exactly = 1) { bookmarkRepository.publishBookmark(signedEventJson) } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:PostBookmarkViewModel.kt$PostBookmarkViewModel${ private val _uiState = MutableStateFlow(PostBookmarkUiState()) val uiState: StateFlow&lt;PostBookmarkUiState&gt; = _uiState.asStateFlow() private var pendingUnsignedEvent: UnsignedNostrEvent? = null /** * Update URL field * * Strips http:// or https:// prefix if present. * * @param input Raw URL input from user */ fun updateUrl(input: String) { val strippedUrl = stripUrlScheme(input) _uiState.update { it.copy(url = strippedUrl) } } /** * Update title field * * @param title New title value */ fun updateTitle(title: String) { _uiState.update { it.copy(title = title) } } /** * Update categories field * * @param categories New categories value (comma-separated) */ fun updateCategories(categories: String) { _uiState.update { it.copy(categories = categories) } } /** * Update comment field * * @param comment New comment value */ fun updateComment(comment: String) { _uiState.update { it.copy(comment = comment) } } /** Dismiss error message */ fun dismissError() { _uiState.update { it.copy(errorMessage = null) } } /** Reset post success state */ fun resetPostSuccess() { _uiState.update { it.copy(postSuccess = false) } } /** * Prepare sign event Intent synchronously (for launcher) * * @param onReady Callback with Intent when ready, or null on failure */ fun prepareSignEventIntent(onReady: (Intent?) -&gt; Unit) { val state = _uiState.value if (state.url.isBlank()) { _uiState.update { it.copy(errorMessage = "URLを入力してください") } onReady(null) return } _uiState.update { it.copy(isSubmitting = true, errorMessage = null) } viewModelScope.launch { val categories = state.categories.split(",").map { it.trim() }.filter { it.isNotBlank() } postBookmarkUseCase .createUnsignedEvent( url = state.url, title = state.title, categories = categories, comment = state.comment) .onSuccess { unsignedEvent -&gt; pendingUnsignedEvent = unsignedEvent val eventJson = unsignedEvent.toJson() _uiState.update { it.copy(unsignedEventJson = eventJson) } val intent = nip55SignerClient.createSignEventIntent(eventJson) onReady(intent) } .onFailure { error -&gt; _uiState.update { it.copy(isSubmitting = false, errorMessage = error.message ?: "イベント作成に失敗しました") } onReady(null) } } } /** * Process signed event response from NIP-55 signer * * NIP-55 signer may return either: * - Complete signed event JSON (if returnType=event works) * - Signature only (hex string) * * This method handles both cases. * * @param resultCode Activity result code * @param data Intent data from signer */ fun processSignedEvent(resultCode: Int, data: Intent?) { nip55SignerClient .handleSignEventResponse(resultCode, data) .onSuccess { response -&gt; viewModelScope.launch { val signedEventJson = buildSignedEventJson(response.signedEventJson) if (signedEventJson == null) { _uiState.update { it.copy(isSubmitting = false, errorMessage = "署名済みイベントの構築に失敗しました") } return@launch } postBookmarkUseCase .publishSignedEvent(signedEventJson) .onSuccess { _uiState.update { it.copy(isSubmitting = false, postSuccess = true) } } .onFailure { error -&gt; _uiState.update { it.copy( isSubmitting = false, errorMessage = error.message ?: "ブックマークの投稿に失敗しました") } } } } .onFailure { error -&gt; _uiState.update { it.copy(isSubmitting = false, errorMessage = error.message ?: "署名がキャンセルされました") } } } /** * Build signed event JSON from signer response * * If response is already valid JSON (complete event), return as-is. If response is signature only * (hex string), combine with pending unsigned event to build complete event. * * @param signerResponse Response from NIP-55 signer * @return Complete signed event JSON or null if building fails */ private fun buildSignedEventJson(signerResponse: String): String? { if (signerResponse.startsWith("{")) { return signerResponse } val unsignedEvent = pendingUnsignedEvent ?: return null return unsignedEvent.toSignedJson(signerResponse) } /** * Strip http:// or https:// scheme from URL * * @param url URL that may contain scheme * @return URL without scheme */ private fun stripUrlScheme(url: String): String { return when { url.startsWith("https://", ignoreCase = true) -&gt; url.substring("https://".length) url.startsWith("http://", ignoreCase = true) -&gt; url.substring("http://".length) else -&gt; url } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest${ private lateinit var postBookmarkUseCase: PostBookmarkUseCase private lateinit var nip55SignerClient: Nip55SignerClient private lateinit var viewModel: PostBookmarkViewModel private val testDispatcher = StandardTestDispatcher() @Before fun setup() { Dispatchers.setMain(testDispatcher) postBookmarkUseCase = mockk(relaxed = true) nip55SignerClient = mockk(relaxed = true) viewModel = PostBookmarkViewModel(postBookmarkUseCase, nip55SignerClient) } @After fun tearDown() { Dispatchers.resetMain() } @Test fun `initial state should have default values`() = runTest { val state = viewModel.uiState.first() assertEquals("url should be empty", "", state.url) assertEquals("title should be empty", "", state.title) assertEquals("categories should be empty", "", state.categories) assertEquals("comment should be empty", "", state.comment) assertFalse("isSubmitting should be false", state.isSubmitting) assertNull("errorMessage should be null", state.errorMessage) assertFalse("postSuccess should be false", state.postSuccess) assertNull("unsignedEventJson should be null", state.unsignedEventJson) } @Test fun `updateUrl should strip https scheme`() = runTest { viewModel.updateUrl("https://example.com/path") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("URL should have https:// stripped", "example.com/path", state.url) } @Test fun `updateUrl should strip http scheme`() = runTest { viewModel.updateUrl("http://example.com/path") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("URL should have http:// stripped", "example.com/path", state.url) } @Test fun `updateUrl should strip HTTPS uppercase scheme`() = runTest { viewModel.updateUrl("HTTPS://example.com/path") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("URL should have HTTPS:// stripped", "example.com/path", state.url) } @Test fun `updateUrl should strip HTTP uppercase scheme`() = runTest { viewModel.updateUrl("HTTP://example.com/path") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("URL should have HTTP:// stripped", "example.com/path", state.url) } @Test fun `updateUrl should keep URL without scheme unchanged`() = runTest { viewModel.updateUrl("example.com/path") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("URL without scheme should remain unchanged", "example.com/path", state.url) } @Test fun `updateTitle should update title`() = runTest { viewModel.updateTitle("Test Title") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("title should be updated", "Test Title", state.title) } @Test fun `updateCategories should update categories`() = runTest { viewModel.updateCategories("tech, kotlin, android") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("categories should be updated", "tech, kotlin, android", state.categories) } @Test fun `updateComment should update comment`() = runTest { viewModel.updateComment("Test comment") advanceUntilIdle() val state = viewModel.uiState.first() assertEquals("comment should be updated", "Test comment", state.comment) } @Test fun `dismissError should clear error message`() = runTest { viewModel.updateUrl("") viewModel.prepareSignEventIntent {} advanceUntilIdle() viewModel.dismissError() advanceUntilIdle() val state = viewModel.uiState.first() assertNull("errorMessage should be null", state.errorMessage) } @Test fun `resetPostSuccess should set postSuccess to false`() = runTest { viewModel.resetPostSuccess() advanceUntilIdle() val state = viewModel.uiState.first() assertFalse("postSuccess should be false", state.postSuccess) } @Test fun `prepareSignEventIntent should set error when URL is blank`() = runTest { viewModel.updateUrl("") advanceUntilIdle() var receivedIntent: Intent? = Intent() viewModel.prepareSignEventIntent { receivedIntent = it } advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertNull("callback should receive null", receivedIntent) } @Test fun `prepareSignEventIntent should call useCase and create intent when URL is valid`() = runTest { val realEvent = UnsignedNostrEvent( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "Test comment") val mockIntent = mockk&lt;Intent&gt;() coEvery { postBookmarkUseCase.createUnsignedEvent(any(), any(), any(), any()) } returns Result.success(realEvent) every { nip55SignerClient.createSignEventIntent(any()) } returns mockIntent viewModel.updateUrl("example.com") viewModel.updateTitle("Test") viewModel.updateCategories("tech, kotlin") viewModel.updateComment("Test comment") advanceUntilIdle() var receivedIntent: Intent? = null viewModel.prepareSignEventIntent { receivedIntent = it } advanceUntilIdle() coVerify { postBookmarkUseCase.createUnsignedEvent("example.com", "Test", any(), "Test comment") } verify { nip55SignerClient.createSignEventIntent(any()) } assertEquals("callback should receive the intent", mockIntent, receivedIntent) } @Test fun `prepareSignEventIntent should set error on useCase failure`() = runTest { coEvery { postBookmarkUseCase.createUnsignedEvent(any(), any(), any(), any()) } returns Result.failure(RuntimeException("Test error")) viewModel.updateUrl("example.com") advanceUntilIdle() viewModel.prepareSignEventIntent {} advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("isSubmitting should be false", state.isSubmitting) } @Test fun `processSignedEvent should publish event on success`() = runTest { val realEvent = UnsignedNostrEvent( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "comment") val signedEventJson = """{"id":"event123","pubkey":"abc","sig":"xyz"}""" val mockPublishResult = PublishResult("event123", listOf("wss://relay.example.com"), emptyList()) val mockIntent = mockk&lt;Intent&gt;() coEvery { postBookmarkUseCase.createUnsignedEvent(any(), any(), any(), any()) } returns Result.success(realEvent) every { nip55SignerClient.createSignEventIntent(any()) } returns mockIntent every { nip55SignerClient.handleSignEventResponse(any(), any()) } returns Result.success(SignedEventResponse(signedEventJson)) coEvery { postBookmarkUseCase.publishSignedEvent(any()) } returns Result.success(mockPublishResult) viewModel.updateUrl("example.com") advanceUntilIdle() viewModel.prepareSignEventIntent {} advanceUntilIdle() viewModel.processSignedEvent(-1, mockIntent) advanceUntilIdle() val state = viewModel.uiState.first() assertTrue("postSuccess should be true", state.postSuccess) assertFalse("isSubmitting should be false", state.isSubmitting) } @Test fun `processSignedEvent should set error on signer failure`() = runTest { val mockIntent = mockk&lt;Intent&gt;() every { nip55SignerClient.handleSignEventResponse(any(), any()) } returns Result.failure(RuntimeException("Signing failed")) viewModel.processSignedEvent(-1, mockIntent) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("isSubmitting should be false", state.isSubmitting) assertFalse("postSuccess should be false", state.postSuccess) } @Test fun `processSignedEvent should set error on publish failure`() = runTest { val realEvent = UnsignedNostrEvent( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "comment") val signedEventJson = """{"id":"event123","pubkey":"abc","sig":"xyz"}""" val mockIntent = mockk&lt;Intent&gt;() coEvery { postBookmarkUseCase.createUnsignedEvent(any(), any(), any(), any()) } returns Result.success(realEvent) every { nip55SignerClient.createSignEventIntent(any()) } returns mockIntent every { nip55SignerClient.handleSignEventResponse(any(), any()) } returns Result.success(SignedEventResponse(signedEventJson)) coEvery { postBookmarkUseCase.publishSignedEvent(any()) } returns Result.failure(RuntimeException("Publish failed")) viewModel.updateUrl("example.com") advanceUntilIdle() viewModel.prepareSignEventIntent {} advanceUntilIdle() viewModel.processSignedEvent(-1, mockIntent) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("isSubmitting should be false", state.isSubmitting) assertFalse("postSuccess should be false", state.postSuccess) } @Test fun `prepareSignEventIntent should parse categories correctly`() = runTest { val realEvent = UnsignedNostrEvent( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = emptyList(), content = "") val mockIntent = mockk&lt;Intent&gt;() coEvery { postBookmarkUseCase.createUnsignedEvent(any(), any(), any(), any()) } returns Result.success(realEvent) every { nip55SignerClient.createSignEventIntent(any()) } returns mockIntent viewModel.updateUrl("example.com") viewModel.updateCategories(" tech , kotlin , , android ") advanceUntilIdle() viewModel.prepareSignEventIntent {} advanceUntilIdle() coVerify { postBookmarkUseCase.createUnsignedEvent( any(), any(), match { it == listOf("tech", "kotlin", "android") }, any()) } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest${ private lateinit var authRepository: AuthRepository private lateinit var loginUseCase: LoginUseCase private lateinit var logoutUseCase: LogoutUseCase private lateinit var getLoginStateUseCase: GetLoginStateUseCase private lateinit var fetchRelayListUseCase: io.github.omochice.pinosu.domain.usecase.FetchRelayListUseCase private lateinit var viewModel: LoginViewModel private val testDispatcher = StandardTestDispatcher() @Before fun setup() { Dispatchers.setMain(testDispatcher) authRepository = mockk(relaxed = true) fetchRelayListUseCase = mockk(relaxed = true) loginUseCase = Nip55LoginUseCase(authRepository) logoutUseCase = Nip55LogoutUseCase(authRepository) getLoginStateUseCase = Nip55GetLoginStateUseCase(authRepository) viewModel = LoginViewModel( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase) } @After fun tearDown() { Dispatchers.resetMain() } /** * Login button tap → NIP-55 signer not installed detection → dialog display * * Integration flow: * 1. User taps login button (LoginViewModel.onLoginButtonClicked) * 2. LoginUseCase verifies NIP-55 signer installation (LoginUseCase.checkNip55SignerInstalled) * 3. NIP-55 signer not installed detected in AuthRepository * 4. ViewModel updates UI state (showNip55InstallDialog = true) */ @Test fun `login flow - when NIP-55 signer not installed - should show install dialog`() = runTest { every { authRepository.checkNip55SignerInstalled() } returns false viewModel.onLoginButtonClicked() advanceUntilIdle() val state = viewModel.uiState.first() assertTrue("showNip55InstallDialog should be true", state.showNip55InstallDialog) assertFalse("isLoading should be false", state.isLoading) assertNull("errorMessage should be null", state.errorMessage) // AuthRepositoryのcheckNip55SignerInstalled()が呼ばれることを確認 // Verify AuthRepository.checkNip55SignerInstalled() is called io.mockk.verify { authRepository.checkNip55SignerInstalled() } } /** * Login success flow → UI state update → display main screen * * Integration flow: * 1. Receive NIP-55 signer response (LoginViewModel.processNip55Response) * 2. AuthRepository response handling * 3. User info save success * 4. ViewModel updates UI state (loginSuccess = true, set userPubkey) */ @Test fun `login flow - when NIP-55 signer response success - should update UI state and navigate to main`() = runTest { val testPubkey = "npub1" + "a".repeat(59) val testUser = User(testPubkey) val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) coEvery { authRepository.processNip55Response(any(), any()) } returns Result.success(testUser) viewModel.processNip55Response(-1, mockIntent) advanceUntilIdle() val loginState = viewModel.uiState.first() val mainState = viewModel.mainUiState.first() assertTrue("loginSuccess should be true", loginState.loginSuccess) assertFalse("isLoading should be false", loginState.isLoading) assertNull("errorMessage should be null", loginState.errorMessage) assertEquals("userPubkey should be set", testPubkey, mainState.userPubkey) coVerify { authRepository.processNip55Response(any(), any()) } } /** * App startup login state check → logged in → display main screen * * Integration flow: * 1. Check login state on app startup (LoginViewModel.checkLoginState) * 2. GetLoginStateUseCase retrieves login state * 3. Retrieve saved user info from AuthRepository * 4. ViewModel updates main screen UI state (set userPubkey) */ @Test fun `startup flow - when user logged in - should restore login state`() = runTest { val testPubkey = "npub1" + "b".repeat(59) val testUser = User(testPubkey) coEvery { authRepository.getLoginState() } returns testUser viewModel.checkLoginState() advanceUntilIdle() val state = viewModel.mainUiState.first() assertEquals("userPubkey should be restored", testPubkey, state.userPubkey) coVerify { authRepository.getLoginState() } } /** * App startup login state check → not logged in → display login screen * * Integration flow: * 1. Check login state on app startup (LoginViewModel.checkLoginState) * 2. GetLoginStateUseCase retrieves login state * 3. AuthRepository returns null (not logged in) * 4. ViewModel main screen UI state remains null */ @Test fun `startup flow - when user not logged in - should keep null state`() = runTest { coEvery { authRepository.getLoginState() } returns null viewModel.checkLoginState() advanceUntilIdle() val state = viewModel.mainUiState.first() assertNull("userPubkey should be null", state.userPubkey) coVerify { authRepository.getLoginState() } } /** * User rejection error → display error message → retry available * * Integration flow: * 1. Receive NIP-55 signer response (LoginViewModel.processNip55Response) * 2. User rejection error detected in AuthRepository * 3. LoginError.UserRejected error is returned * 4. ViewModel sets error message * 5. User taps retry button (onRetryLogin) */ @Test fun `error flow - when user rejected - should show error and allow retry`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val error = LoginError.UserRejected coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) every { authRepository.checkNip55SignerInstalled() } returns true viewModel.processNip55Response(-1, mockIntent) advanceUntilIdle() val stateAfterError = viewModel.uiState.first() assertNotNull("errorMessage should be set", stateAfterError.errorMessage) assertFalse("loginSuccess should be false", stateAfterError.loginSuccess) assertFalse("isLoading should be false", stateAfterError.isLoading) viewModel.onRetryLogin() advanceUntilIdle() io.mockk.verify(atLeast = 1) { authRepository.checkNip55SignerInstalled() } } /** * Timeout error → display timeout message → retry available * * Integration flow: * 1. Receive NIP-55 signer response (LoginViewModel.processNip55Response) * 2. Timeout error detected in AuthRepository * 3. LoginError.Timeout error is returned * 4. ViewModel sets timeout message */ @Test fun `error flow - when timeout - should show timeout error message`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val error = LoginError.Timeout coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) viewModel.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertTrue( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true) assertFalse("loginSuccess should be false", state.loginSuccess) assertFalse("isLoading should be false", state.isLoading) } /** * Network error → display error message * * Integration flow: * 1. Receive NIP-55 signer response (LoginViewModel.processNip55Response) * 2. Network error detected in AuthRepository * 3. LoginError.NetworkError error is returned * 4. ViewModel sets error message */ @Test fun `error flow - when network error - should show network error message`() = runTest { val mockIntent = mockk&lt;android.content.Intent&gt;(relaxed = true) val error = LoginError.NetworkError("Connection failed") coEvery { authRepository.processNip55Response(any(), any()) } returns Result.failure(error) viewModel.processNip55Response(-1, mockIntent) advanceUntilIdle() val state = viewModel.uiState.first() assertNotNull("errorMessage should be set", state.errorMessage) assertFalse("loginSuccess should be false", state.loginSuccess) assertFalse("isLoading should be false", state.isLoading) } /** * Close error dialog → clear error state * * Integration flow: * 1. Error occurs and dialog is displayed * 2. User closes error dialog (dismissError) * 3. ViewModel clears error state */ @Test fun `error flow - when error dismissed - should clear error state`() = runTest { every { authRepository.checkNip55SignerInstalled() } returns false viewModel.onLoginButtonClicked() advanceUntilIdle() val stateBeforeDismiss = viewModel.uiState.first() assertTrue("showNip55InstallDialog should be true", stateBeforeDismiss.showNip55InstallDialog) viewModel.dismissError() advanceUntilIdle() val stateAfterDismiss = viewModel.uiState.first() assertNull("errorMessage should be null", stateAfterDismiss.errorMessage) assertFalse("showNip55InstallDialog should be false", stateAfterDismiss.showNip55InstallDialog) } /** * Logout success flow → clear login state → display login screen * * Integration flow: * 1. User taps logout button (LoginViewModel.onLogoutButtonClicked) * 2. LogoutUseCase executes logout * 3. AuthRepository successfully clears login state * 4. ViewModel updates UI state (userPubkey = null) */ @Test fun `logout flow - when logout success - should clear login state`() = runTest { val testPubkey = "npub1" + "c".repeat(59) val testUser = User(testPubkey) coEvery { authRepository.getLoginState() } returns testUser viewModel.checkLoginState() advanceUntilIdle() val stateBeforeLogout = viewModel.mainUiState.first() assertEquals("userPubkey should be set", testPubkey, stateBeforeLogout.userPubkey) coEvery { authRepository.logout() } returns Result.success(Unit) viewModel.onLogoutButtonClicked() advanceUntilIdle() val stateAfterLogout = viewModel.mainUiState.first() assertNull("userPubkey should be null after logout", stateAfterLogout.userPubkey) assertFalse("isLoggingOut should be false", stateAfterLogout.isLoggingOut) coVerify { authRepository.logout() } } /** * Logout failure flow → error handling → maintain login state * * Integration flow: * 1. User taps logout button (LoginViewModel.onLogoutButtonClicked) * 2. LogoutUseCase executes logout * 3. Storage error occurs in AuthRepository * 4. ViewModel handles error (isLoggingOut = false) */ @Test fun `logout flow - when logout fails - should handle error gracefully`() = runTest { val testPubkey = "npub1" + "d".repeat(59) val testUser = User(testPubkey) coEvery { authRepository.getLoginState() } returns testUser viewModel.checkLoginState() advanceUntilIdle() val error = LogoutError.StorageError("Failed to clear storage") coEvery { authRepository.logout() } returns Result.failure(error) viewModel.onLogoutButtonClicked() advanceUntilIdle() val state = viewModel.mainUiState.first() assertFalse("isLoggingOut should be false after error", state.isLoggingOut) coVerify { authRepository.logout() } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:RelayBookmarkRepository.kt$RelayBookmarkRepository${ companion object { private const val TAG = "RelayBookmarkRepository" const val KIND_BOOKMARK_LIST = 39701 const val PER_RELAY_TIMEOUT_MS = 10000L const val DEFAULT_RELAY_URL = "wss://yabu.me" private fun isValidUrl(url: String): Boolean { return try { val uri = URI(url) uri.scheme in listOf("http", "https") &amp;&amp; uri.host != null } catch (e: Exception) { false } } } /** * Retrieve bookmark list for the specified public key * * @param pubkey Nostr public key (Bech32-encoded format, starts with npub1) * @return Success(BookmarkList) if found, Success(null) if no bookmarks, Failure on error */ override suspend fun getBookmarkList(pubkey: String): Result&lt;BookmarkList?&gt; { return try { val hexPubkey = Bech32.npubToHex(pubkey) ?: return Result.failure(IllegalArgumentException("Invalid npub format")) val relays = getRelaysForQuery() val filter = """{"kinds":[$KIND_BOOKMARK_LIST],"limit":10}""" val events = relayPool.subscribeWithTimeout(relays, filter, PER_RELAY_TIMEOUT_MS) if (events.isEmpty()) { return Result.success(null) } val allItems = mutableListOf&lt;BookmarkItem&gt;() val mostRecentEvent = events.maxByOrNull { it.createdAt } events.forEach { event -&gt; val dTags = event.tags .filter { it.isNotEmpty() &amp;&amp; it[0] == "d" } .mapNotNull { it.getOrNull(1) } .map { "https://$it" } .filter { isValidUrl(it) } val rTags = event.tags.filter { it.isNotEmpty() &amp;&amp; it[0] == "r" }.mapNotNull { it.getOrNull(1) } val urls = when { dTags.isNotEmpty() -&gt; dTags rTags.isNotEmpty() -&gt; rTags else -&gt; return@forEach } val titleTag = event.tags.firstOrNull { it.size &gt;= 2 &amp;&amp; it[0] == "title" }?.get(1) val (title, titleSource) = if (titleTag != null) { titleTag to "tag" } else { val fetchedTitle = urlMetadataFetcher.fetchTitle(urls.first()).getOrNull() fetchedTitle to "metadata" } val item = BookmarkItem( type = "event", eventId = event.id, url = urls.first(), urls = urls, title = title, titleSource = titleSource, event = BookmarkedEvent( kind = event.kind, content = event.content, author = event.pubkey, createdAt = event.createdAt, tags = event.tags)) allItems.add(item) } val itemsWithEvents = allItems.sortedByDescending { it.event?.createdAt ?: 0L } val event = mostRecentEvent ?: return Result.success(null) val encryptedContent = if (event.content.isNotEmpty()) event.content else null Result.success( BookmarkList( pubkey = event.pubkey, items = itemsWithEvents, createdAt = event.createdAt, encryptedContent = encryptedContent)) } catch (e: Exception) { Log.e(TAG, "Error getting bookmark list", e) Result.failure(e) } } /** * Get relay list for querying bookmarks * * Returns cached relay list from LocalAuthDataSource, or default relay if not available. * * @return List of relay configurations for querying */ private suspend fun getRelaysForQuery(): List&lt;RelayConfig&gt; { val cachedRelays = localAuthDataSource.getRelayList() return if (cachedRelays.isNullOrEmpty()) { Log.d(TAG, "No cached relay list, using default relay: $DEFAULT_RELAY_URL") listOf(RelayConfig(url = DEFAULT_RELAY_URL)) } else { Log.d(TAG, "Using ${cachedRelays.size} cached relays") cachedRelays } } /** * Create an unsigned bookmark event * * @param hexPubkey Author's public key (hex-encoded) * @param url URL to bookmark (without scheme) * @param title Bookmark title * @param categories List of categories (t-tags) * @param comment Bookmark comment (content) * @return Unsigned event ready for NIP-55 signing */ override fun createBookmarkEvent( hexPubkey: String, url: String, title: String, categories: List&lt;String&gt;, comment: String ): UnsignedNostrEvent { val tags = mutableListOf&lt;List&lt;String&gt;&gt;() val rawUrl = url.trim() val normalizedUrl = when { rawUrl.startsWith("https://", ignoreCase = true) -&gt; rawUrl.substring("https://".length) rawUrl.startsWith("http://", ignoreCase = true) -&gt; rawUrl.substring("http://".length) else -&gt; rawUrl } tags.add(listOf("d", normalizedUrl)) if (title.isNotBlank()) { tags.add(listOf("title", title)) } categories .filter { it.isNotBlank() } .forEach { category -&gt; tags.add(listOf("t", category.trim())) } val fullUrl = if (rawUrl.startsWith("http://", ignoreCase = true) || rawUrl.startsWith("https://", ignoreCase = true)) { rawUrl } else { "https://$normalizedUrl" } tags.add(listOf("r", fullUrl)) return UnsignedNostrEvent( pubkey = hexPubkey, createdAt = System.currentTimeMillis() / 1000, kind = KIND_BOOKMARK_LIST, tags = tags, content = comment) } /** * Publish a signed bookmark event to relays * * @param signedEventJson Signed event as JSON string * @return Result containing PublishResult on success or error on failure */ override suspend fun publishBookmark(signedEventJson: String): Result&lt;PublishResult&gt; { return try { val relays = getRelaysForQuery() relayPool.publishEvent(relays, signedEventJson, PER_RELAY_TIMEOUT_MS) } catch (e: Exception) { Log.e(TAG, "Error publishing bookmark", e) Result.failure(e) } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:RelayConfigTest.kt$RelayConfigTest${ @Test fun `constructor with all parameters should set values correctly`() { val config = RelayConfig(url = "wss://relay.example.com", read = true, write = false) assertEquals("URL should match", "wss://relay.example.com", config.url) assertTrue("read should be true", config.read) assertFalse("write should be false", config.write) } @Test fun `constructor without optional parameters should use default values`() { val config = RelayConfig(url = "wss://relay.example.com") assertEquals("URL should match", "wss://relay.example.com", config.url) assertTrue("read should default to true", config.read) assertTrue("write should default to true", config.write) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:RelayPool.kt$RelayPool${ /** * Subscribe to events from multiple relays with timeout * * Connects to all specified relays in parallel, collects events, deduplicates by event ID, and * returns the merged result. * * @param relays List of relay configurations to query * @param filter Nostr filter as JSON string * @param timeoutMs Timeout in milliseconds for each relay * @return List of deduplicated events from all relays */ suspend fun subscribeWithTimeout( relays: List&lt;RelayConfig&gt;, filter: String, timeoutMs: Long ): List&lt;NostrEvent&gt; /** * Publish an event to multiple relays * * Sends the signed event to all write-enabled relays in parallel and waits for OK responses. * * @param relays List of relay configurations (only write-enabled relays will be used) * @param signedEventJson Signed event as JSON string * @param timeoutMs Timeout in milliseconds for each relay * @return Result containing PublishResult on success or error on failure */ suspend fun publishEvent( relays: List&lt;RelayConfig&gt;, signedEventJson: String, timeoutMs: Long ): Result&lt;PublishResult&gt; }</ID>
    <ID>NoEmptyFirstLineInClassBody:SettingsRepository.kt$SettingsRepository${ /** Current theme mode as reactive stream */ val themeMode: StateFlow&lt;ThemeMode&gt; /** Get current theme mode */ fun getThemeMode(): ThemeMode /** Set theme mode */ fun setThemeMode(mode: ThemeMode) }</ID>
    <ID>NoEmptyFirstLineInClassBody:SettingsRepositoryImplTest.kt$SettingsRepositoryImplTest${ private lateinit var sharedPreferences: android.content.SharedPreferences private lateinit var localSettingsDataSource: LocalSettingsDataSource private lateinit var settingsRepository: SettingsRepository @Before fun setup() { val context = RuntimeEnvironment.getApplication() sharedPreferences = context.getSharedPreferences("test_settings", Context.MODE_PRIVATE) sharedPreferences.edit().clear().commit() localSettingsDataSource = LocalSettingsDataSource(context) localSettingsDataSource.setTestSharedPreferences(sharedPreferences) settingsRepository = SettingsRepositoryImpl(localSettingsDataSource) } @Test fun `initial value is System`() { val result = settingsRepository.themeMode.value assertEquals(ThemeMode.System, result) } @Test fun `getThemeMode default System`() { val result = settingsRepository.getThemeMode() assertEquals(ThemeMode.System, result) } @Test fun `setThemeMode updates flow`() { settingsRepository.setThemeMode(ThemeMode.Dark) assertEquals(ThemeMode.Dark, settingsRepository.themeMode.value) } @Test fun `setThemeMode persists`() { settingsRepository.setThemeMode(ThemeMode.Light) assertEquals(ThemeMode.Light, localSettingsDataSource.getThemeMode()) } @Test fun `getThemeMode reads flow`() { settingsRepository.setThemeMode(ThemeMode.Dark) assertEquals(ThemeMode.Dark, settingsRepository.getThemeMode()) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:SettingsViewModel.kt$SettingsViewModel${ private val _uiState = MutableStateFlow(SettingsUiState(themeMode = settingsRepository.getThemeMode())) val uiState: StateFlow&lt;SettingsUiState&gt; = _uiState.asStateFlow() /** * Update theme mode selection * * @param mode New theme mode to apply */ fun setThemeMode(mode: ThemeMode) { settingsRepository.setThemeMode(mode) _uiState.value = _uiState.value.copy(themeMode = mode) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:SettingsViewModelTest.kt$SettingsViewModelTest${ private lateinit var settingsRepository: SettingsRepository private lateinit var viewModel: SettingsViewModel @Before fun setup() { settingsRepository = mockk() every { settingsRepository.getThemeMode() } returns ThemeMode.System every { settingsRepository.setThemeMode(any()) } returns Unit viewModel = SettingsViewModel(settingsRepository) } @Test fun `initial state is System`() = runTest { val state = viewModel.uiState.first() assertEquals(ThemeMode.System, state.themeMode) } @Test fun `setThemeMode updates state`() = runTest { viewModel.setThemeMode(ThemeMode.Dark) val state = viewModel.uiState.first() assertEquals(ThemeMode.Dark, state.themeMode) } @Test fun `setThemeMode calls repo`() = runTest { viewModel.setThemeMode(ThemeMode.Light) verify { settingsRepository.setThemeMode(ThemeMode.Light) } } @Test fun `all modes update correctly`() = runTest { viewModel.setThemeMode(ThemeMode.Light) assertEquals(ThemeMode.Light, viewModel.uiState.first().themeMode) viewModel.setThemeMode(ThemeMode.Dark) assertEquals(ThemeMode.Dark, viewModel.uiState.first().themeMode) viewModel.setThemeMode(ThemeMode.System) assertEquals(ThemeMode.System, viewModel.uiState.first().themeMode) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:ThemeModeTest.kt$ThemeModeTest${ @Test fun `has exactly three entries`() { assertEquals(3, ThemeMode.entries.size) } @Test fun `entries order is correct`() { val entries = ThemeMode.entries assertEquals(ThemeMode.Light, entries[0]) assertEquals(ThemeMode.Dark, entries[1]) assertEquals(ThemeMode.System, entries[2]) } }</ID>
    <ID>NoEmptyFirstLineInClassBody:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher${ companion object { private const val TAG = "UrlMetadataFetcher" private const val MAX_CACHE_SIZE = 100 } // Simple in-memory cache: URL -&gt; Title private val cache = LruCache&lt;String, String&gt;(MAX_CACHE_SIZE) override suspend fun fetchTitle(url: String): Result&lt;String?&gt; { // Check cache first cache.get(url)?.let { return Result.success(it) } return withContext(Dispatchers.IO) { try { val request = Request.Builder().url(url).header("User-Agent", "Pinosu/1.0 (Android)").build() val response = okHttpClient.newCall(request).execute() if (!response.isSuccessful) { Log.w(TAG, "HTTP request failed with code: ${response.code}") return@withContext Result.failure(Exception("HTTP ${response.code}")) } val html = response.body?.string() if (html == null) { Log.w(TAG, "Response body is null") return@withContext Result.failure(Exception("Empty response body")) } val title = parseOgTitle(html) if (title != null) { // Cache if found cache.put(url, title) } Result.success(title) } catch (e: Exception) { Log.w(TAG, "Failed to fetch metadata for $url: ${e.message}") Result.failure(e) } } } /** * Parse Open Graph title or HTML title from HTML content * * Priority: * 1. og:title meta tag * 2. &lt;title&gt; tag * * @param html HTML content * @return Title string or null if not found */ private fun parseOgTitle(html: String): String? { try { val doc = Jsoup.parse(html) // Priority 1: og:title doc.selectFirst("meta[property=og:title]") ?.attr("content") ?.takeIf { it.isNotBlank() } ?.let { return it } // Priority 2: &lt;title&gt; tag doc.selectFirst("title") ?.text() ?.takeIf { it.isNotBlank() } ?.let { return it } return null } catch (e: Exception) { Log.w(TAG, "Failed to parse HTML: ${e.message}") return null } } }</ID>
    <ID>NoEmptyFirstLineInClassBody:UseCaseModule.kt$UseCaseModule${ @Binds abstract fun bindLoginUseCase(impl: Nip55LoginUseCase): LoginUseCase @Binds abstract fun bindLogoutUseCase(impl: Nip55LogoutUseCase): LogoutUseCase @Binds abstract fun bindGetLoginStateUseCase(impl: Nip55GetLoginStateUseCase): GetLoginStateUseCase @Binds abstract fun bindGetBookmarkListUseCase(impl: GetBookmarkListUseCaseImpl): GetBookmarkListUseCase @Binds abstract fun bindFetchRelayListUseCase(impl: FetchRelayListUseCaseImpl): FetchRelayListUseCase @Binds abstract fun bindPostBookmarkUseCase(impl: PostBookmarkUseCaseImpl): PostBookmarkUseCase }</ID>
    <ID>NoEmptyFirstLineInClassBody:UserTest.kt$UserTest${ /** Valid pubkey（Bech32 format）can create User test */ @Test fun `create User with valid pubkey`() { val validPubkey = "npub1" + "a".repeat(59) val user = User(validPubkey) assertEquals(validPubkey, user.pubkey) } /** Another valid pubkey（Bech32 format with numbers and lowercase）can create User test */ @Test fun `create User with valid hex pubkey containing numbers`() { val validPubkey = "npub1" + "0123456789abcdef".repeat(3) + "0123456789a" val user = User(validPubkey) assertTrue(user.pubkey.startsWith("npub1")) assertEquals(validPubkey, user.pubkey) } /** Test IllegalArgumentException thrown for pubkey not starting with npub1 */ @Test(expected = IllegalArgumentException::class) fun `create User with pubkey too short throws exception`() { val shortPubkey = "npub" + "a".repeat(59) // starts with npub, not npub1 User(shortPubkey) } /** Test IllegalArgumentException thrown for hex format (old format) pubkey */ @Test(expected = IllegalArgumentException::class) fun `create User with pubkey too long throws exception`() { val longPubkey = "a".repeat(64) // hex format without npub1 prefix User(longPubkey) } /** Test IllegalArgumentException thrown for pubkey not starting with npub1 (uppercase NPUB1) */ @Test(expected = IllegalArgumentException::class) fun `create User with uppercase characters throws exception`() { val invalidPubkey = "NPUB1" + "A".repeat(59) // uppercase NPUB1 User(invalidPubkey) } /** Test IllegalArgumentException thrown for pubkey starting with nsec (secret key format) */ @Test(expected = IllegalArgumentException::class) fun `create User with non-hex characters throws exception`() { val invalidPubkey = "nsec1" + "g".repeat(59) // nsec1 is secret key format User(invalidPubkey) } /** Test IllegalArgumentException thrown for empty pubkey */ @Test(expected = IllegalArgumentException::class) fun `create User with empty pubkey throws exception`() { User("") } /** Test IllegalArgumentException thrown for pubkey starting with nprofile1 (profile format) */ @Test(expected = IllegalArgumentException::class) fun `create User with spaces throws exception`() { val invalidPubkey = "nprofile1" + "a".repeat(54) // nprofile1 is profile format User(invalidPubkey) } /** User equality（data class property）test */ @Test fun `User equality works correctly`() { val pubkey = "npub1" + "a".repeat(59) val user1 = User(pubkey) val user2 = User(pubkey) assertEquals(user1, user2) assertEquals(user1.hashCode(), user2.hashCode()) } /** Test User with different pubkey is not equal */ @Test fun `Users with different pubkeys are not equal`() { val user1 = User("npub1" + "a".repeat(59)) val user2 = User("npub1" + "b".repeat(59)) assertNotEquals(user1, user2) } }</ID>
    <ID>NoEmptyFirstLineInMethodBlock:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$ </ID>
    <ID>NoWildcardImports:AuthEventTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:BookmarkViewModelTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:ErrorTypesTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:GetLoginStateUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:LoginUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:LoginViewModelTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:LogoutUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:Nip55AuthRepositoryTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:Nip55SignerClientTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:PostBookmarkUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:PresentationDomainIntegrationTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:UserTest.kt$import org.junit.Assert.*</ID>
    <ID>OutdatedDocumentation:BookmarkFilterMode.kt$BookmarkFilterMode</ID>
    <ID>OutdatedDocumentation:BookmarkScreen.kt$@OptIn(ExperimentalMaterial3Api::class) @Composable fun BookmarkScreen( uiState: BookmarkUiState, onRefresh: () -&gt; Unit, onLoad: () -&gt; Unit, onOpenDrawer: () -&gt; Unit = {}, onTabSelected: (BookmarkFilterMode) -&gt; Unit = {}, onAddBookmark: () -&gt; Unit = {}, viewModel: BookmarkViewModel? = null, )</ID>
    <ID>OutdatedDocumentation:BookmarkViewModel.kt$BookmarkViewModel : ViewModel</ID>
    <ID>OutdatedDocumentation:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl : FetchRelayListUseCase</ID>
    <ID>OutdatedDocumentation:GetBookmarkListUseCaseImpl.kt$GetBookmarkListUseCaseImpl : GetBookmarkListUseCase</ID>
    <ID>OutdatedDocumentation:LoginViewModel.kt$LoginViewModel : ViewModel</ID>
    <ID>OutdatedDocumentation:Nip55AuthRepository.kt$Nip55AuthRepository : AuthRepository</ID>
    <ID>OutdatedDocumentation:Nip55GetLoginStateUseCase.kt$Nip55GetLoginStateUseCase : GetLoginStateUseCase</ID>
    <ID>OutdatedDocumentation:Nip55LoginUseCase.kt$Nip55LoginUseCase : LoginUseCase</ID>
    <ID>OutdatedDocumentation:Nip55LogoutUseCase.kt$Nip55LogoutUseCase : LogoutUseCase</ID>
    <ID>OutdatedDocumentation:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl : Nip65RelayListFetcher</ID>
    <ID>OutdatedDocumentation:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl : PostBookmarkUseCase</ID>
    <ID>OutdatedDocumentation:PostBookmarkViewModel.kt$PostBookmarkViewModel : ViewModel</ID>
    <ID>OutdatedDocumentation:RelayBookmarkRepository.kt$RelayBookmarkRepository : BookmarkRepository</ID>
    <ID>OutdatedDocumentation:RelayPool.kt$RelayPoolImpl : RelayPool</ID>
    <ID>OutdatedDocumentation:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher : UrlMetadataFetcher</ID>
    <ID>ReturnCount:LocalAuthDataSource.kt$LocalAuthDataSource$suspend fun getUser(): User?</ID>
    <ID>ReturnCount:Nip55SignerClient.kt$Nip55SignerClient$fun handleNip55Response(resultCode: Int, data: Intent?): Result&lt;Nip55Response&gt;</ID>
    <ID>ReturnCount:Nip55SignerClient.kt$Nip55SignerClient$fun handleSignEventResponse(resultCode: Int, data: Intent?): Result&lt;SignedEventResponse&gt;</ID>
    <ID>ReturnCount:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$override suspend fun fetchRelayList(hexPubkey: String): Result&lt;List&lt;RelayConfig&gt;&gt;</ID>
    <ID>ReturnCount:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$override suspend fun createUnsignedEvent( url: String, title: String, categories: List&lt;String&gt;, comment: String ): Result&lt;UnsignedNostrEvent&gt;</ID>
    <ID>ReturnCount:RelayBookmarkRepository.kt$RelayBookmarkRepository$override suspend fun getBookmarkList(pubkey: String): Result&lt;BookmarkList?&gt;</ID>
    <ID>ReturnCount:RelayPool.kt$RelayPoolImpl$override suspend fun publishEvent( relays: List&lt;RelayConfig&gt;, signedEventJson: String, timeoutMs: Long ): Result&lt;PublishResult&gt;</ID>
    <ID>ReturnCount:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$private fun parseOgTitle(html: String): String?</ID>
    <ID>SpacingBetweenDeclarationsWithAnnotations:RelayPoolTest.kt$RelayPoolTest.MockPublishWebSocketState$@Volatile private var wsListener: WebSocketListener? = null</ID>
    <ID>SpacingBetweenDeclarationsWithAnnotations:RelayPoolTest.kt$RelayPoolTest.MockWebSocketState$@Volatile private var wsListener: WebSocketListener? = null</ID>
    <ID>StringLiteralDuplication:NostrRelayMessage.kt$NostrRelayMessageSerializer$"Subscription ID must be a string"</ID>
    <ID>StringLiteralDuplication:RelayBookmarkRepository.kt$RelayBookmarkRepository$"http://"</ID>
    <ID>StringLiteralDuplication:RelayBookmarkRepository.kt$RelayBookmarkRepository$"https://"</ID>
    <ID>StringShouldBeRawString:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$"\"authors\":[\"$hexPubkey\"]"</ID>
    <ID>StringTemplate:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$${createdAt}</ID>
    <ID>SwallowedException:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$e: Exception</ID>
    <ID>SwallowedException:LocalAuthDataSource.kt$LocalAuthDataSource$e: Exception</ID>
    <ID>SwallowedException:Nip55SignerClient.kt$Nip55SignerClient$e: Exception</ID>
    <ID>SwallowedException:Nip55SignerClient.kt$Nip55SignerClient$e: PackageManager.NameNotFoundException</ID>
    <ID>SwallowedException:RelayBookmarkRepository.kt$RelayBookmarkRepository.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BookmarkScreen.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LocalAuthDataSource.kt$LocalAuthDataSource$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Nip55SignerClient.kt$Nip55SignerClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RelayBookmarkRepository.kt$RelayBookmarkRepository$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RelayBookmarkRepository.kt$RelayBookmarkRepository.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RelayPool.kt$RelayPoolImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RelayPool.kt$RelayPoolImpl.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:UrlMetadataFetcher.kt$OkHttpUrlMetadataFetcher$e: Exception</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( icon = Icons.AutoMirrored.Filled.ExitToApp, text = stringResource(R.string.menu_logout), onClick = { onCloseDrawer() onLogout() })</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( icon = Icons.AutoMirrored.Filled.List, text = stringResource(R.string.menu_licenses), onClick = { onCloseDrawer() onNavigateToLicense() })</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( icon = Icons.Default.Info, text = stringResource(R.string.menu_app_info), onClick = { onCloseDrawer() onNavigateToAppInfo() })</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( icon = Icons.Default.Settings, text = stringResource(R.string.menu_settings), onClick = { onCloseDrawer() onNavigateToSettings() })</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( onNavigateToSettings = {}, onNavigateToLicense = {}, onNavigateToAppInfo = {}, onLogout = {}, onCloseDrawer = {})</ID>
    <ID>TrailingCommaOnCallSite:AppDrawer.kt$( text = stringResource(R.string.app_name), style = MaterialTheme.typography.titleLarge, modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp))</ID>
    <ID>TrailingCommaOnCallSite:AppInfoScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>TrailingCommaOnCallSite:AppInfoScreen.kt$( text = stringResource(R.string.app_name), style = MaterialTheme.typography.headlineMedium)</ID>
    <ID>TrailingCommaOnCallSite:AppInfoScreen.kt$( text = stringResource(R.string.label_version), style = MaterialTheme.typography.titleMedium)</ID>
    <ID>TrailingCommaOnCallSite:AppInfoScreen.kt$( title = { Text(stringResource(R.string.title_app_info)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( bookmark = bookmark, onClick = { clickedBookmark -&gt; viewModel?.let { vm -&gt; if (clickedBookmark.urls.size == 1) { try { uriHandler.openUri(clickedBookmark.urls.first()) } catch (e: Exception) { vm.setUrlOpenError(e.message ?: urlOpenErrorText) } } else { vm.onBookmarkCardClicked(clickedBookmark) } } })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( isRefreshing = uiState.isLoading, onRefresh = onRefresh, modifier = Modifier.padding(paddingValues).fillMaxSize())</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( kind = 39701, content = "Fetched title from OG metadata.", author = "efgh5678efgh5678", createdAt = System.currentTimeMillis() / 1000 - 3600, tags = emptyList())</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( kind = 39701, content = "This is a sample bookmark description from the event content.", author = "abcd1234abcd1234", createdAt = System.currentTimeMillis() / 1000, tags = emptyList())</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( modifier = Modifier.fillMaxSize(), contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( modifier = Modifier.fillMaxWidth() .then(if (hasUrls) Modifier.clickable { onClick(bookmark) } else Modifier), elevation = CardDefaults.cardElevation(defaultElevation = 2.dp), colors = CardDefaults.cardColors( containerColor = if (hasUrls) MaterialTheme.colorScheme.surface else MaterialTheme.colorScheme.surfaceVariant))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( selected = uiState.selectedTab == BookmarkFilterMode.Global, onClick = { onTabSelected(BookmarkFilterMode.Global) }, text = { Text(stringResource(R.string.tab_global)) })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( selected = uiState.selectedTab == BookmarkFilterMode.Local, onClick = { onTabSelected(BookmarkFilterMode.Local) }, text = { Text(stringResource(R.string.tab_local)) })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = "(Title from OG metadata)", style = MaterialTheme.typography.labelSmall, color = MaterialTheme.colorScheme.tertiary)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = "URLs (${bookmark.urls.size})", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.tertiary)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = description, style = MaterialTheme.typography.bodyMedium, maxLines = 3, overflow = TextOverflow.Ellipsis)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = formatTimestamp(event.createdAt), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = stringResource(R.string.message_no_bookmarks), style = MaterialTheme.typography.bodyLarge)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = title, style = MaterialTheme.typography.titleLarge, color = MaterialTheme.colorScheme.primary, maxLines = 2, overflow = TextOverflow.Ellipsis)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = uiState.error, style = MaterialTheme.typography.bodyLarge, color = MaterialTheme.colorScheme.error)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( text = url, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary, modifier = Modifier.padding(vertical = 2.dp), maxLines = 1, overflow = TextOverflow.Ellipsis)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( title = { Text(stringResource(R.string.title_bookmarks)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( topBar = { Column { TopAppBar( title = { Text(stringResource(R.string.title_bookmarks)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } }) PrimaryTabRow( selectedTabIndex = if (uiState.selectedTab == BookmarkFilterMode.Local) 0 else 1) { Tab( selected = uiState.selectedTab == BookmarkFilterMode.Local, onClick = { onTabSelected(BookmarkFilterMode.Local) }, text = { Text(stringResource(R.string.tab_local)) }) Tab( selected = uiState.selectedTab == BookmarkFilterMode.Global, onClick = { onTabSelected(BookmarkFilterMode.Global) }, text = { Text(stringResource(R.string.tab_global)) }) } } }, floatingActionButton = { FloatingActionButton(onClick = onAddBookmark) { Icon(imageVector = Icons.Filled.Add, contentDescription = "Add bookmark") } })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( type = "event", eventId = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", title = "Example Article Title", url = "https://example.com/article", urls = listOf("https://example.com/article", "https://example.com/related"), titleSource = "tag", event = BookmarkedEvent( kind = 39701, content = "This is a sample bookmark description from the event content.", author = "abcd1234abcd1234", createdAt = System.currentTimeMillis() / 1000, tags = emptyList()))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( type = "event", eventId = "abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890", title = "Another Bookmark", url = "https://example.com/another", urls = listOf("https://example.com/another"), titleSource = "metadata", event = BookmarkedEvent( kind = 39701, content = "Fetched title from OG metadata.", author = "efgh5678efgh5678", createdAt = System.currentTimeMillis() / 1000 - 3600, tags = emptyList()))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( uiState = BookmarkUiState(isLoading = false, bookmarks = emptyList()), onRefresh = {}, onLoad = {})</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( uiState = BookmarkUiState(isLoading = false, bookmarks = sampleBookmarks), onRefresh = {}, onLoad = {})</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( uiState.bookmarks, key = { bookmark -&gt; "${bookmark.type}:${bookmark.eventId ?: bookmark.hashCode()}" })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkScreen.kt$( urls = bookmark.urls, onUrlSelected = { url -&gt; vm.dismissUrlDialog() try { uriHandler.openUri(url) } catch (e: Exception) { vm.setUrlOpenError(e.message ?: urlOpenErrorText) } }, onDismiss = { vm.dismissUrlDialog() })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModel.kt$BookmarkViewModel$( isLoading = false, allBookmarks = allItems, userHexPubkey = userHexPubkey, error = null)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModel.kt$BookmarkViewModel$( isLoading = false, error = "Not logged in", allBookmarks = emptyList(), bookmarks = emptyList())</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModel.kt$BookmarkViewModel$( onSuccess = { bookmarkList -&gt; val allItems = bookmarkList?.items ?: emptyList() _uiState.update { state -&gt; val updatedState = state.copy( isLoading = false, allBookmarks = allItems, userHexPubkey = userHexPubkey, error = null) updatedState.copy(bookmarks = filterBookmarks(updatedState)) } }, onFailure = { e -&gt; _uiState.value = _uiState.value.copy( isLoading = false, error = e.message ?: "Failed to load bookmarks") })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "All bookmarks should have matching author", state.bookmarks.all { it.event?.author == "author1" })</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be null after dismissing", state.selectedBookmarkForUrlDialog)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be set for multiple URLs", state.selectedBookmarkForUrlDialog)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedBookmarkForUrlDialog should be the clicked bookmark", bookmarkWithMultipleUrls, state.selectedBookmarkForUrlDialog)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( "selectedTab should be Global after selecting", BookmarkFilterMode.Global, state.selectedTab)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( allBookmarks = testBookmarks, userHexPubkey = "author1", selectedTab = BookmarkFilterMode.Global)</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( createTestBookmarkItem("id1", "author1"), createTestBookmarkItem("id2", "author2"), createTestBookmarkItem("id3", "author1"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( kind = 39701, content = "content", author = author, createdAt = System.currentTimeMillis() / 1000, tags = emptyList())</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "concurrent-test", title = "Concurrent Test", urls = listOf("https://example.com/1", "https://example.com/2"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "id1", title = "Bookmark 1", urls = listOf("https://example.com/1"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "test789", title = "Multiple URLs Bookmark", urls = listOf( "https://example.com/1", "https://example.com/2", "https://example.com/3"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "test999", title = "Test Dismiss", urls = listOf("https://example.com/a", "https://example.com/b"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = "workflow-test", title = "Workflow Test", urls = listOf("https://example.com/1", "https://example.com/2"))</ID>
    <ID>TrailingCommaOnCallSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( type = "event", eventId = eventId, title = "Test $eventId", urls = listOf("https://example.com/$eventId"), event = io.github.omochice.pinosu.domain.model.BookmarkedEvent( kind = 39701, content = "content", author = author, createdAt = System.currentTimeMillis() / 1000, tags = emptyList()))</ID>
    <ID>TrailingCommaOnCallSite:DrawerMenuItem.kt$( modifier = modifier .fillMaxWidth() .clickable(onClick = onClick) .padding(horizontal = 16.dp, vertical = 12.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>TrailingCommaOnCallSite:ErrorDialog.kt$( onDismissRequest = onDismiss, title = { Text(stringResource(R.string.dialog_title_error)) }, text = { Text(message) }, confirmButton = { Button(onClick = onDismiss) { Text(stringResource(R.string.button_ok)) } })</ID>
    <ID>TrailingCommaOnCallSite:ErrorTypesTest.kt$ErrorTypesTest$( LoginError.Nip55SignerNotInstalled, LoginError.UserRejected, LoginError.Timeout, LoginError.NetworkError("test"), LoginError.UnknownError(RuntimeException()))</ID>
    <ID>TrailingCommaOnCallSite:ErrorTypesTest.kt$ErrorTypesTest$( Nip55Error.NotInstalled, Nip55Error.UserRejected, Nip55Error.Timeout, Nip55Error.InvalidResponse("test"), Nip55Error.IntentResolutionError("test"))</ID>
    <ID>TrailingCommaOnCallSite:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$( "Should propagate original error message", "Network error", result.exceptionOrNull()?.message)</ID>
    <ID>TrailingCommaOnCallSite:LicenseScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>TrailingCommaOnCallSite:LicenseScreen.kt$( title = { Text(stringResource(R.string.title_licenses)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>TrailingCommaOnCallSite:LocalAuthDataSource.kt$LocalAuthDataSource.Companion$( context, "pinosu_auth_prefs", masterKey, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM)</ID>
    <ID>TrailingCommaOnCallSite:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$( RelayConfig(url = "wss://relay1.example.com", read = true, write = true), RelayConfig(url = "wss://relay2.example.com", read = true, write = false))</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center, modifier = Modifier.padding(16.dp))</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( onDismissRequest = onDismissDialog, title = { Text(stringResource(R.string.dialog_title_error)) }, text = { Text(uiState.errorMessage) }, confirmButton = { if (isTimeoutError) { Button(onClick = onRetry) { Text(stringResource(R.string.button_retry)) } } else { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_ok)) } } }, dismissButton = { if (isTimeoutError) { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_cancel)) } } else { null } })</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( onDismissRequest = onDismissDialog, title = { Text(stringResource(R.string.dialog_title_nip55_signer_required)) }, text = { Text(stringResource(R.string.dialog_message_nip55_signer_required)) }, confirmButton = { Button(onClick = onInstallNip55Signer) { Text(stringResource(R.string.button_install)) } }, dismissButton = { TextButton(onClick = onDismissDialog) { Text(stringResource(R.string.button_close)) } })</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( text = stringResource(R.string.message_loading), style = MaterialTheme.typography.bodyMedium)</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( text = stringResource(R.string.message_login_success), style = MaterialTheme.typography.headlineSmall, color = MaterialTheme.colorScheme.primary)</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( uiState = LoginUiState( errorMessage = "Login process timed out. Please check the NIP-55 signer app and retry."), onLoginButtonClick = {})</ID>
    <ID>TrailingCommaOnCallSite:LoginScreen.kt$( uiState = LoginUiState(errorMessage = "Login was cancelled. Please try again."), onLoginButtonClick = {})</ID>
    <ID>TrailingCommaOnCallSite:LoginViewModelTest.kt$LoginViewModelTest$( "errorMessage should be null (relay fetch failure is logged, not shown)", state.errorMessage)</ID>
    <ID>TrailingCommaOnCallSite:LoginViewModelTest.kt$LoginViewModelTest$( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true)</ID>
    <ID>TrailingCommaOnCallSite:LoginViewModelTest.kt$LoginViewModelTest$( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase)</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( enterTransition = { EnterTransition.None }, exitTransition = { ExitTransition.None }, popEnterTransition = { EnterTransition.None }, popExitTransition = { ExitTransition.None })</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( enterTransition = { defaultEnterTransition }, exitTransition = { defaultExitTransition }, popEnterTransition = { defaultPopEnterTransition }, popExitTransition = { defaultPopExitTransition })</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( uiState = bookmarkUiState, onRefresh = { bookmarkViewModel.refresh() }, onLoad = { bookmarkViewModel.loadBookmarks() }, onOpenDrawer = { scope.launch { drawerState.open() } }, onTabSelected = { tab -&gt; bookmarkViewModel.selectTab(tab) }, onAddBookmark = { navController.navigate(PostBookmark) }, viewModel = bookmarkViewModel)</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( uiState = loginUiState, onLoginButtonClick = { viewModel.onLoginButtonClicked() if (nip55SignerClient.checkNip55SignerInstalled()) { val intent = nip55SignerClient.createPublicKeyIntent() nip55Launcher.launch(intent) } }, onDismissDialog = { viewModel.dismissError() }, onInstallNip55Signer = { // TODO: Implement Play Store link }, onRetry = { viewModel.onRetryLogin() if (nip55SignerClient.checkNip55SignerInstalled()) { val intent = nip55SignerClient.createPublicKeyIntent() nip55Launcher.launch(intent) } }, onLoginSuccess = { navController.navigate(Bookmark) { popUpTo&lt;Login&gt; { inclusive = true } } viewModel.dismissError() })</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( uiState = mainUiState, onLogout = { viewModel.onLogoutButtonClicked() }, onOpenDrawer = { scope.launch { drawerState.open() } }, onNavigateToLogin = {})</ID>
    <ID>TrailingCommaOnCallSite:MainActivity.kt$( uiState = postBookmarkUiState, onUrlChange = { postBookmarkViewModel.updateUrl(it) }, onTitleChange = { postBookmarkViewModel.updateTitle(it) }, onCategoriesChange = { postBookmarkViewModel.updateCategories(it) }, onCommentChange = { postBookmarkViewModel.updateComment(it) }, onPostClick = { postBookmarkViewModel.prepareSignEventIntent { intent -&gt; intent?.let { signEventLauncher.launch(it) } } }, onNavigateBack = { navController.navigateUp() }, onDismissError = { postBookmarkViewModel.dismissError() })</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( modifier = Modifier.padding(paddingValues).fillMaxSize(), color = MaterialTheme.colorScheme.background)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( text = formatPubkey(uiState.userPubkey), style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( text = stringResource(R.string.message_logging_out), style = MaterialTheme.typography.bodyLarge, textAlign = TextAlign.Center)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( text = stringResource(R.string.text_logged_in), style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( text = stringResource(R.string.text_not_logged_in), style = MaterialTheme.typography.headlineMedium, textAlign = TextAlign.Center)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( title = { Text(stringResource(R.string.app_name)) }, navigationIcon = { IconButton(onClick = onOpenDrawer) { Icon(imageVector = Icons.Default.Menu, contentDescription = "Open menu") } })</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( userPubkey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", isLoggingOut = false)</ID>
    <ID>TrailingCommaOnCallSite:MainScreen.kt$( userPubkey = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef", isLoggingOut = true)</ID>
    <ID>TrailingCommaOnCallSite:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$( "Exception should be LoginError.Nip55SignerNotInstalled", exception is LoginError.Nip55SignerNotInstalled)</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Error should be InvalidResponse", error is Nip55Error.InvalidResponse || error.toString().contains("InvalidResponse"))</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Error should be UserRejected", error is Nip55Error.UserRejected || error.toString().contains("UserRejected"))</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Intent should have SINGLE_TOP and CLEAR_TOP flags", (intent.flags and expectedFlags) == expectedFlags)</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Package should be NIP-55 signer package name", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, intent.`package`)</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "PackageName should be NIP-55 signer package", Nip55SignerClient.NIP55_SIGNER_PACKAGE_NAME, response?.packageName)</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "Type extra should be get_public_key", Nip55SignerClient.TYPE_GET_PUBLIC_KEY, intent.getStringExtra("type"))</ID>
    <ID>TrailingCommaOnCallSite:Nip55SignerClientTest.kt$Nip55SignerClientTest$( "URI scheme should be nostrsigner", Nip55SignerClient.NOSTRSIGNER_SCHEME, intent.data?.scheme)</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( id = "test-event-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 10002, tags = tags, content = "")</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( id = "test-id", pubkey = "test-pubkey", createdAt = 1234567890L, kind = 1, // Wrong kind, should be 10002 tags = listOf(listOf("r", "wss://relay.example.com")), content = "")</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r"), // Missing URL listOf("r", "wss://valid-relay.example.com"))</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "http://not-websocket.example.com"), listOf("r", "wss://valid-relay.example.com"))</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "wss://relay.example.com"), listOf("p", "pubkey123"), listOf("e", "eventid456"))</ID>
    <ID>TrailingCommaOnCallSite:Nip65EventParserTest.kt$Nip65EventParserTest$( listOf("r", "wss://relay1.example.com"), listOf("r", "wss://relay2.example.com", "read"), listOf("r", "wss://relay3.example.com", "write"))</ID>
    <ID>TrailingCommaOnCallSite:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( "Exception message should be preserved", result.exceptionOrNull()?.message?.contains("Network error") == true)</ID>
    <ID>TrailingCommaOnCallSite:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( any(), match { it.contains("\"kinds\":[10002]") &amp;&amp; it.contains("\"authors\":[\"$hexPubkey\"]") }, any())</ID>
    <ID>TrailingCommaOnCallSite:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( id = "test-event-id-${createdAt}", pubkey = pubkey, createdAt = createdAt, kind = 10002, tags = tags, content = "")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( onClick = onPostClick, modifier = Modifier.fillMaxWidth(), enabled = uiState.url.isNotBlank())</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( text = "URL", style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( text = "https://", style = MaterialTheme.typography.bodyLarge, color = MaterialTheme.colorScheme.onSurfaceVariant)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( title = { Text("ブックマークを追加") }, navigationIcon = { IconButton(onClick = onNavigateBack) { Icon(imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "戻る") } })</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState( url = "example.com/article", title = "Sample Article", categories = "tech, kotlin", comment = "This is a great article about Kotlin"), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState(), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( uiState = PostBookmarkUiState(isSubmitting = true), onUrlChange = {}, onTitleChange = {}, onCategoriesChange = {}, onCommentChange = {}, onPostClick = {}, onNavigateBack = {}, onDismissError = {})</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( url = "example.com/article", title = "Sample Article", categories = "tech, kotlin", comment = "This is a great article about Kotlin")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( value = uiState.categories, onValueChange = onCategoriesChange, modifier = Modifier.fillMaxWidth(), label = { Text("カテゴリ") }, singleLine = true, placeholder = { Text("tech, programming, kotlin") }, supportingText = { Text("カンマ区切りで複数入力できます") })</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( value = uiState.comment, onValueChange = onCommentChange, modifier = Modifier.fillMaxWidth().height(120.dp), label = { Text("コメント") }, placeholder = { Text("ブックマークについてのメモ") }, maxLines = 5)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( value = uiState.title, onValueChange = onTitleChange, modifier = Modifier.fillMaxWidth(), label = { Text("タイトル") }, singleLine = true, placeholder = { Text("ブックマークのタイトル") })</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkScreen.kt$( value = uiState.url, onValueChange = onUrlChange, modifier = Modifier.weight(1f), singleLine = true, placeholder = { Text("example.com/path") })</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$( hexPubkey = hexPubkey, url = url, title = title, categories = categories, comment = comment)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( eventId = "abc123", successfulRelays = listOf("wss://relay1.example.com"), failedRelays = emptyList())</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( hexPubkey = any(), url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( pubkey = hexPubkey, createdAt = 1234567890L, kind = 39701, tags = listOf(listOf("r", "https://example.com/article")), content = "Great article")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$( url = "example.com/article", title = "Test Article", categories = listOf("tech"), comment = "Great article")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkViewModel.kt$PostBookmarkViewModel$( url = state.url, title = state.title, categories = categories, comment = state.comment)</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = emptyList(), content = "")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "Test comment")</ID>
    <ID>TrailingCommaOnCallSite:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$( pubkey = "abc123def456abc123def456abc123def456abc123def456abc123def456abc1", createdAt = 1234567890, kind = 39701, tags = listOf(listOf("d", "example.com")), content = "comment")</ID>
    <ID>TrailingCommaOnCallSite:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$( "errorMessage should contain timeout info", state.errorMessage?.contains("timed out") == true)</ID>
    <ID>TrailingCommaOnCallSite:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$( loginUseCase, logoutUseCase, getLoginStateUseCase, authRepository, fetchRelayListUseCase)</ID>
    <ID>TrailingCommaOnCallSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( kind = event.kind, content = event.content, author = event.pubkey, createdAt = event.createdAt, tags = event.tags)</ID>
    <ID>TrailingCommaOnCallSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( pubkey = event.pubkey, items = itemsWithEvents, createdAt = event.createdAt, encryptedContent = encryptedContent)</ID>
    <ID>TrailingCommaOnCallSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( pubkey = hexPubkey, createdAt = System.currentTimeMillis() / 1000, kind = KIND_BOOKMARK_LIST, tags = tags, content = comment)</ID>
    <ID>TrailingCommaOnCallSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( type = "event", eventId = event.id, url = urls.first(), urls = urls, title = title, titleSource = titleSource, event = BookmarkedEvent( kind = event.kind, content = event.content, author = event.pubkey, createdAt = event.createdAt, tags = event.tags))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Error should mention failed to publish", result.exceptionOrNull()?.message?.contains("Failed to publish") == true)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Error should mention invalid JSON", result.exceptionOrNull()?.message?.contains("Invalid JSON") == true)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Error should mention no write-enabled relays", result.exceptionOrNull()?.message?.contains("No write-enabled relays") == true)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Failed relay should be rejecting", publishResult?.failedRelays?.any { it.first == "wss://rejecting.example.com" } == true)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Should have 1 successful relay", listOf("wss://relay.example.com"), publishResult?.successfulRelays)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Should only have write-enabled relay in success list", listOf("wss://write-relay.example.com"), publishResult?.successfulRelays)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( "Successful relay should be accepting", publishResult?.successfulRelays?.contains("wss://accepting.example.com") == true)</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://accepting.example.com", write = true), RelayConfig(url = "wss://rejecting.example.com", write = true))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://failing.example.com"), RelayConfig(url = "wss://working.example.com"))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://read-only-relay.example.com", write = false), RelayConfig(url = "wss://write-relay.example.com", write = true))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://relay1.example.com"), RelayConfig(url = "wss://relay2.example.com"))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( RelayConfig(url = "wss://relay1.example.com", write = false), RelayConfig(url = "wss://relay2.example.com", write = false))</ID>
    <ID>TrailingCommaOnCallSite:RelayPoolTest.kt$RelayPoolTest$( id = id, pubkey = pubkey, createdAt = System.currentTimeMillis() / 1000, kind = 39701, tags = listOf(listOf("r", "https://example.com")), content = "")</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up")</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( mode = mode, selected = uiState.themeMode == mode, onClick = { onThemeModeSelected(mode) })</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( modifier = Modifier.fillMaxWidth().clickable(onClick = onClick).padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( text = stringResource( when (mode) { ThemeMode.Light -&gt; R.string.theme_light ThemeMode.Dark -&gt; R.string.theme_dark ThemeMode.System -&gt; R.string.theme_system }), style = MaterialTheme.typography.bodyLarge)</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( text = stringResource(R.string.label_theme), style = MaterialTheme.typography.titleMedium)</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( title = { Text(stringResource(R.string.title_settings)) }, navigationIcon = { IconButton(onClick = onNavigateUp) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Navigate up") } })</ID>
    <ID>TrailingCommaOnCallSite:SettingsScreen.kt$( uiState = SettingsUiState(themeMode = ThemeMode.System), onThemeModeSelected = {}, onNavigateUp = {})</ID>
    <ID>TrailingCommaOnCallSite:UrlSelectionDialog.kt$( modifier = Modifier.fillMaxWidth() .clickable { selectedUrl = url } .padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically)</ID>
    <ID>TrailingCommaOnCallSite:UrlSelectionDialog.kt$( onDismissRequest = onDismiss, title = { Text(stringResource(R.string.dialog_title_select_url)) }, text = { Column(modifier = Modifier.fillMaxWidth().verticalScroll(rememberScrollState())) { urls.forEach { url -&gt; Row( modifier = Modifier.fillMaxWidth() .clickable { selectedUrl = url } .padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) { RadioButton(selected = selectedUrl == url, onClick = { selectedUrl = url }) Text( text = url, modifier = Modifier.padding(start = 8.dp), style = MaterialTheme.typography.bodyMedium, maxLines = 2, overflow = TextOverflow.Ellipsis) } } } }, confirmButton = { Button(onClick = { selectedUrl?.let(onUrlSelected) }, enabled = selectedUrl != null) { Text(stringResource(R.string.button_open)) } }, dismissButton = { TextButton(onClick = onDismiss) { Text(stringResource(R.string.button_cancel)) } })</ID>
    <ID>TrailingCommaOnCallSite:UrlSelectionDialog.kt$( text = url, modifier = Modifier.padding(start = 8.dp), style = MaterialTheme.typography.bodyMedium, maxLines = 2, overflow = TextOverflow.Ellipsis)</ID>
    <ID>TrailingCommaOnDeclarationSite:AppDrawer.kt$( onNavigateToSettings: () -&gt; Unit, onNavigateToLicense: () -&gt; Unit, onNavigateToAppInfo: () -&gt; Unit, onLogout: () -&gt; Unit, onCloseDrawer: () -&gt; Unit, modifier: Modifier = Modifier )</ID>
    <ID>TrailingCommaOnDeclarationSite:BookmarkFilterMode.kt$BookmarkFilterMode</ID>
    <ID>TrailingCommaOnDeclarationSite:BookmarkRepository.kt$BookmarkRepository$( hexPubkey: String, url: String, title: String, categories: List&lt;String&gt;, comment: String )</ID>
    <ID>TrailingCommaOnDeclarationSite:BookmarkViewModelTest.kt$BookmarkViewModelTest$( allBookmarks: List&lt;BookmarkItem&gt; = emptyList(), userHexPubkey: String? = null, selectedTab: BookmarkFilterMode = BookmarkFilterMode.Local )</ID>
    <ID>TrailingCommaOnDeclarationSite:DrawerMenuItem.kt$( icon: ImageVector, text: String, onClick: () -&gt; Unit, modifier: Modifier = Modifier )</ID>
    <ID>TrailingCommaOnDeclarationSite:LoginScreen.kt$( uiState: LoginUiState, onLoginButtonClick: () -&gt; Unit, onDismissDialog: () -&gt; Unit = {}, onInstallNip55Signer: () -&gt; Unit = {}, onRetry: () -&gt; Unit = {}, onLoginSuccess: () -&gt; Unit = {} )</ID>
    <ID>TrailingCommaOnDeclarationSite:MainActivityTest.kt$MainActivityTest$( getLoginStateUseCase: GetLoginStateUseCase )</ID>
    <ID>TrailingCommaOnDeclarationSite:Nip55AuthRepository.kt$Nip55AuthRepository$( private val nip55SignerClient: Nip55SignerClient, private val localAuthDataSource: LocalAuthDataSource )</ID>
    <ID>TrailingCommaOnDeclarationSite:Nip55AuthRepository.kt$Nip55AuthRepository$is Nip55Error.InvalidResponse, is Nip55Error.IntentResolutionError -&gt; LoginError.NetworkError(nip55Error?.toString() ?: "Unknown NIP-55 signer error")</ID>
    <ID>TrailingCommaOnDeclarationSite:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$( pubkey: String, tags: List&lt;List&lt;String&gt;&gt;, createdAt: Long = 1234567890L )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkScreen.kt$( uiState: PostBookmarkUiState, onUrlChange: (String) -&gt; Unit, onTitleChange: (String) -&gt; Unit, onCategoriesChange: (String) -&gt; Unit, onCommentChange: (String) -&gt; Unit, onPostClick: () -&gt; Unit, onNavigateBack: () -&gt; Unit, onDismissError: () -&gt; Unit )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkUiState.kt$PostBookmarkUiState$( val url: String = "", val title: String = "", val categories: String = "", val comment: String = "", val isSubmitting: Boolean = false, val errorMessage: String? = null, val postSuccess: Boolean = false, val unsignedEventJson: String? = null )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkUseCase.kt$PostBookmarkUseCase$( url: String, title: String, categories: List&lt;String&gt;, comment: String )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$( private val bookmarkRepository: BookmarkRepository, private val getLoginStateUseCase: GetLoginStateUseCase )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$( url: String, title: String, categories: List&lt;String&gt;, comment: String )</ID>
    <ID>TrailingCommaOnDeclarationSite:PostBookmarkViewModel.kt$PostBookmarkViewModel$( private val postBookmarkUseCase: PostBookmarkUseCase, private val nip55SignerClient: Nip55SignerClient )</ID>
    <ID>TrailingCommaOnDeclarationSite:PublishResult.kt$PublishResult$( val eventId: String, val successfulRelays: List&lt;String&gt;, val failedRelays: List&lt;Pair&lt;String, String&gt;&gt; )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( hexPubkey: String, url: String, title: String, categories: List&lt;String&gt;, comment: String )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayBookmarkRepository.kt$RelayBookmarkRepository$( private val relayPool: RelayPool, private val localAuthDataSource: LocalAuthDataSource, private val urlMetadataFetcher: UrlMetadataFetcher )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPool.kt$RelayPool$( relays: List&lt;RelayConfig&gt;, filter: String, timeoutMs: Long )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPool.kt$RelayPool$( relays: List&lt;RelayConfig&gt;, signedEventJson: String, timeoutMs: Long )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPool.kt$RelayPoolImpl$( relayUrl: String, signedEventJson: String )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPool.kt$RelayPoolImpl$( relays: List&lt;RelayConfig&gt;, filter: String, timeoutMs: Long )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPool.kt$RelayPoolImpl$( relays: List&lt;RelayConfig&gt;, signedEventJson: String, timeoutMs: Long )</ID>
    <ID>TrailingCommaOnDeclarationSite:RelayPoolTest.kt$RelayPoolTest.MockPublishWebSocketState$( private val accepted: Boolean, private val message: String = "" )</ID>
    <ID>TrailingCommaOnDeclarationSite:SettingsScreen.kt$( uiState: SettingsUiState, onThemeModeSelected: (ThemeMode) -&gt; Unit, onNavigateUp: () -&gt; Unit )</ID>
    <ID>TrailingCommaOnDeclarationSite:ThemeMode.kt$ThemeMode</ID>
    <ID>TrailingCommaOnDeclarationSite:UnsignedNostrEvent.kt$UnsignedNostrEvent$( val pubkey: String, val createdAt: Long, val kind: Int, val tags: List&lt;List&lt;String&gt;&gt;, val content: String )</ID>
    <ID>TryCatchFinallySpacing:RelayPoolTest.kt$RelayPoolTest.MockPublishWebSocketState${}</ID>
    <ID>TryCatchFinallySpacing:RelayPoolTest.kt$RelayPoolTest.MockWebSocketState${}</ID>
    <ID>UnderscoresInNumericLiterals:BookmarkScreen.kt$39701</ID>
    <ID>UnderscoresInNumericLiterals:BookmarkViewModelTest.kt$BookmarkViewModelTest$39701</ID>
    <ID>UnderscoresInNumericLiterals:Nip65EventParser.kt$Nip65EventParserImpl.Companion$10002</ID>
    <ID>UnderscoresInNumericLiterals:Nip65EventParserTest.kt$Nip65EventParserTest$10002</ID>
    <ID>UnderscoresInNumericLiterals:Nip65EventParserTest.kt$Nip65EventParserTest$1234567890L</ID>
    <ID>UnderscoresInNumericLiterals:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl.Companion$10000L</ID>
    <ID>UnderscoresInNumericLiterals:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$10002</ID>
    <ID>UnderscoresInNumericLiterals:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$1234567890L</ID>
    <ID>UnderscoresInNumericLiterals:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$1234567890L</ID>
    <ID>UnderscoresInNumericLiterals:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$39701</ID>
    <ID>UnderscoresInNumericLiterals:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$1234567890</ID>
    <ID>UnderscoresInNumericLiterals:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$39701</ID>
    <ID>UnderscoresInNumericLiterals:RelayBookmarkRepository.kt$RelayBookmarkRepository.Companion$10000L</ID>
    <ID>UnderscoresInNumericLiterals:RelayBookmarkRepository.kt$RelayBookmarkRepository.Companion$39701</ID>
    <ID>UnderscoresInNumericLiterals:RelayPoolTest.kt$RelayPoolTest$39701</ID>
    <ID>UnnecessaryParentheses:Nip55SignerClientTest.kt$Nip55SignerClientTest$(intent.flags and expectedFlags)</ID>
    <ID>UnusedPrivateMember:AppDrawer.kt$@Preview(showBackground = true) @Composable private fun AppDrawerPreview()</ID>
    <ID>UnusedPrivateMember:AppInfoScreen.kt$@Preview(showBackground = true) @Composable private fun AppInfoScreenPreview()</ID>
    <ID>UnusedPrivateMember:BookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun BookmarkScreenEmptyPreview()</ID>
    <ID>UnusedPrivateMember:BookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun BookmarkScreenLoadingPreview()</ID>
    <ID>UnusedPrivateMember:BookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun BookmarkScreenWithDataPreview()</ID>
    <ID>UnusedPrivateMember:DrawerMenuItem.kt$@Preview(showBackground = true) @Composable private fun DrawerMenuItemPreview()</ID>
    <ID>UnusedPrivateMember:LicenseScreen.kt$@Preview(showBackground = true) @Composable private fun LicenseScreenPreview()</ID>
    <ID>UnusedPrivateMember:MainScreen.kt$@Preview(showBackground = true) @Composable private fun MainScreenLoggedInPreview()</ID>
    <ID>UnusedPrivateMember:MainScreen.kt$@Preview(showBackground = true) @Composable private fun MainScreenLoggingOutPreview()</ID>
    <ID>UnusedPrivateMember:MainScreen.kt$@Preview(showBackground = true) @Composable private fun MainScreenNotLoggedInPreview()</ID>
    <ID>UnusedPrivateMember:PostBookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun PostBookmarkScreenFilledPreview()</ID>
    <ID>UnusedPrivateMember:PostBookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun PostBookmarkScreenLoadingPreview()</ID>
    <ID>UnusedPrivateMember:PostBookmarkScreen.kt$@Preview(showBackground = true) @Composable private fun PostBookmarkScreenPreview()</ID>
    <ID>WildcardImport:AuthEventTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:BookmarkViewModelTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ErrorTypesTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:GetLoginStateUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:LoginUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:LoginViewModelTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:LogoutUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:Nip55AuthRepositoryTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:Nip55SignerClientTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:PostBookmarkUseCaseTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:PresentationDomainIntegrationTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:UserTest.kt$import org.junit.Assert.*</ID>
    <ID>Wrapping:AppDrawer.kt$(</ID>
    <ID>Wrapping:AppInfoScreen.kt$(</ID>
    <ID>Wrapping:BookmarkScreen.kt$(</ID>
    <ID>Wrapping:BookmarkViewModel.kt$BookmarkViewModel$(</ID>
    <ID>Wrapping:BookmarkViewModelTest.kt$BookmarkViewModelTest$(</ID>
    <ID>Wrapping:DrawerMenuItem.kt$(</ID>
    <ID>Wrapping:ErrorDialog.kt$(</ID>
    <ID>Wrapping:ErrorTypesTest.kt$ErrorTypesTest$(</ID>
    <ID>Wrapping:FetchRelayListUseCase.kt$FetchRelayListUseCaseImpl$(</ID>
    <ID>Wrapping:FetchRelayListUseCaseTest.kt$FetchRelayListUseCaseTest$(</ID>
    <ID>Wrapping:LicenseScreen.kt$(</ID>
    <ID>Wrapping:LocalAuthDataSource.kt$LocalAuthDataSource.Companion$(</ID>
    <ID>Wrapping:LocalAuthDataSourceTest.kt$LocalAuthDataSourceTest$(</ID>
    <ID>Wrapping:LoginScreen.kt$(</ID>
    <ID>Wrapping:LoginViewModel.kt$LoginViewModel$(</ID>
    <ID>Wrapping:LoginViewModelTest.kt$LoginViewModelTest$(</ID>
    <ID>Wrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest$(</ID>
    <ID>Wrapping:MainActivity.kt$(</ID>
    <ID>Wrapping:MainScreen.kt$(</ID>
    <ID>Wrapping:Nip55AuthRepositoryTest.kt$Nip55AuthRepositoryTest$(</ID>
    <ID>Wrapping:Nip55SignerClient.kt$Nip55SignerClient$(</ID>
    <ID>Wrapping:Nip55SignerClientTest.kt$Nip55SignerClientTest$(</ID>
    <ID>Wrapping:Nip65EventParserTest.kt$Nip65EventParserTest$(</ID>
    <ID>Wrapping:Nip65RelayListFetcher.kt$Nip65RelayListFetcherImpl$(</ID>
    <ID>Wrapping:Nip65RelayListFetcherTest.kt$Nip65RelayListFetcherTest$(</ID>
    <ID>Wrapping:PostBookmarkScreen.kt$(</ID>
    <ID>Wrapping:PostBookmarkUseCaseImpl.kt$PostBookmarkUseCaseImpl$(</ID>
    <ID>Wrapping:PostBookmarkUseCaseTest.kt$PostBookmarkUseCaseTest$(</ID>
    <ID>Wrapping:PostBookmarkViewModel.kt$PostBookmarkViewModel$(</ID>
    <ID>Wrapping:PostBookmarkViewModelTest.kt$PostBookmarkViewModelTest$(</ID>
    <ID>Wrapping:PresentationDomainIntegrationTest.kt$PresentationDomainIntegrationTest$(</ID>
    <ID>Wrapping:RelayBookmarkRepository.kt$RelayBookmarkRepository$(</ID>
    <ID>Wrapping:RelayPool.kt$RelayPoolImpl$(</ID>
    <ID>Wrapping:RelayPoolTest.kt$RelayPoolTest$(</ID>
    <ID>Wrapping:SettingsScreen.kt$(</ID>
    <ID>Wrapping:UrlSelectionDialog.kt$(</ID>
  </CurrentIssues>
</SmellBaseline>
