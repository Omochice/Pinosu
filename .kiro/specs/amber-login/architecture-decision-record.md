# Amber Login - Architecture Decision Record

## 機能のGoal

本機能は、NostrブックマークアプリケーションPinosuにおける認証基盤として、次のように実現します。

- セキュアなログイン: AmberアプリとのNIP-55プロトコル統合により、秘密鍵を一切保持せずにセキュアなログイン機能を提供
- ログイン状態の永続化: アプリ再起動後もユーザー体験を維持するため、ログイン状態をローカルストレージに安全に保存
- Amber未インストール時のガイダンス: Amberアプリ未インストール時にユーザーガイダンス（Google Play Storeへの誘導）を提供
- Android標準のセキュリティ遵守: Android Keystore、EncryptedSharedPreferencesを活用したベストプラクティスに準拠したセキュリティ実装

## 機能のNon-Goal

本機能では次の項目を意図的に実装しません。

- リレーサーバーへの接続: 将来フェーズで実装予定
- ブックマーク機能（kind 10003）: 本フェーズではログイン機能のみ
- 複数アカウント管理: 単一ユーザーのみサポート
- iOS対応: Android限定
- NIP-46リレー経由通信の直接実装: NIP-55を使用するため不要
- オフライン認証機能: Amberとの通信が前提

---

## 選択した技術

### 1. NIP-55プロトコル（Amber通信）

#### Pros

- 公式サポート: AmberがNIP-55を公式にサポートしており、実績がある
- Android標準のIntent機構: Android標準のIntent機構を使用するため信頼性が高く、プラットフォームとの親和性が高い
- ユーザー承認フロー組み込み: ユーザー承認フローが標準化されており、セキュアなUXを提供
- 広範な採用実績: Amethyst、0xChat、Voyage、Fountainなど他のNostr Androidアプリでも広く採用されている
- セキュリティ: 秘密鍵がAmber側で管理されるため、Pinosuアプリ側でのセキュリティリスクを最小化

#### Cons

- Android限定: iOSでは別の実装方法が必要（本プロジェクトではAndroid限定のため影響なし）
- Amberインストール必須: ユーザーがAmberアプリをインストールしていない場合、ログイン不可（ガイダンスで軽減）
- 外部依存: Amberアプリのメンテナンス状況に依存する

### 2. Amethyst Quartz（Nostrライブラリ）

#### Pros

- Amber統合サポート: `NostrSignerExternal`クラスがAmber統合を直接サポート
- 実戦投入済み: Amethystで実際に運用されており、信頼性が高い
- 将来の拡張性: リレー通信やその他のNIP実装が容易に追加可能
- Maven Central提供: 依存関係管理が簡単で、標準的なビルドプロセスに統合可能
- 実装時間短縮: プロトコル実装を自前で行う必要がなく、開発効率が向上

#### Cons

- 外部依存関係: ライブラリのバージョン互換性やメンテナンス状況に依存
- 学習コスト: ライブラリのAPI仕様を理解する必要がある
- ライブラリサイズ: アプリサイズが増加する可能性がある

### 3. Clean Architecture + MVVM + Jetpack Compose

#### Pros

- Google公式推奨: Android開発における標準的なアーキテクチャパターン
- Jetpack Composeとの親和性: モダンなUI開発フレームワークと最も相性が良い
- テスタビリティ: ViewModel単体テストが容易で、レイヤー分離により依存関係の管理が明確
- 保守性と拡張性: 関心の分離により将来の機能拡張が容易で、コードの保守性が高い
- 状態管理の明確化: ログイン状態管理がViewModelで明確化され、UI層とビジネスロジックが分離される

#### Cons

- 初期実装の複雑性: レイヤー分離によりボイラープレートコードが増加
- 学習コスト: Clean Architectureの概念理解が必要
- 小規模アプリには過剰: 単純なログイン機能だけであれば、より簡素なパターンでも十分な場合がある

### 4. Android Keystore + EncryptedSharedPreferences

#### Pros

- Android Jetpack Security標準: Android公式のセキュリティライブラリで信頼性が高い
- 自動暗号化: データがAES256で自動的に暗号化される
- ハードウェア保護: マスターキーがAndroid Keystoreで保護され、TEE/SEを活用
- 実装の簡潔性: 複雑な暗号化処理を意識せずに実装可能
- セキュリティベストプラクティス: 2024年時点のAndroidセキュリティ標準に準拠

#### Cons

- Android 6.0+ (API 23+) 必須: 古いデバイスでは使用不可（本プロジェクトはminSdk 26のため影響なし）
- 鍵マテリアルのバックアップ不可: デバイス移行時にログイン状態が消失（再認証が必要）
- 暗号化オーバーヘッド: わずかなパフォーマンスオーバーヘッドが発生する可能性

### 5. ActivityResultAPI

#### Pros

- モダンAPI: `startActivityForResult()`の非推奨化に伴う推奨代替手段
- Android 13+対応: 最新のAndroidバージョンでの動作が保証される
- タイプセーフ: Contract-based APIによりタイプセーフな実装が可能
- ライフサイクル管理: Androidのライフサイクルと自動的に統合され、メモリリークを防止
- Jetpack Compose統合: ComposeとのシームレスなインテグレーションUiがメモリリークを防止

#### Cons

- 学習コスト: 新しいAPIパラダイムの理解が必要
- 古い実装からの移行: レガシーコードからの移行が必要な場合がある

---

## 比較検討した技術

### 代替案1: NIP-46直接実装（リレー経由通信）

#### Pros

- プラットフォーム非依存: Android以外のプラットフォームでも同じ実装が使用可能
- サーバーレス: 完全な分散型アーキテクチャ
- 外部アプリ不要: Amberアプリのインストールが不要

#### Cons

- 実装複雑性: リレーサーバー通信、NIP-44暗号化、JSON-RPC実装など複雑な実装が必要
- ネットワーク依存: リレーサーバーへのネットワーク接続が必須
- レイテンシ: リレー経由の通信のため、レスポンス時間が長くなる
- セキュリティリスク: 秘密鍵の管理が複雑になる可能性

### 代替案2: nostr-java-library

#### Pros

- JVM標準: Javaベースのライブラリで、標準的なJVM環境で動作
- 別の選択肢: Quartzに問題が発生した場合の代替手段となる

#### Cons

- Amber統合サポート不明: `NostrSignerExternal`相当の機能があるか不明
- 実績不足: Quartz程の実戦投入実績がない
- ドキュメント: Quartzと比較してドキュメントやコミュニティサポートが限定的

### 代替案3: 独自Nostrプロトコル実装

#### Pros

- 完全なコントロール: プロトコル実装の完全なコントロールが可能
- 外部依存なし: ライブラリのメンテナンス状況に影響されない
- 最適化: プロジェクト固有の最適化が可能

#### Cons

- 実装時間: プロトコル実装に膨大な時間とリソースが必要
- テストとデバッグ: プロトコル準拠性の検証が困難
- 保守コスト: NIP仕様変更への対応が必要
- バグリスク: 実装バグによるセキュリティリスク

### 代替案4: MVC (Model-View-Controller)

#### Pros

- シンプル: 実装が単純で理解しやすい
- 学習コスト低: 従来型のパターンで学習コストが低い

#### Cons

- 状態管理が煩雑: UIの状態管理が複雑になりがち
- Jetpack Composeとの相性: モダンなAndroid開発との相性が悪い
- テスタビリティ: ViewとControllerが密結合になりやすく、テストが困難
- 非推奨: レガシーアプローチとして扱われている

### 代替案5: 平文SharedPreferences

#### Pros

- シンプル: 実装が最も単純
- パフォーマンス: 暗号化オーバーヘッドがない

#### Cons

- セキュリティリスク: データが平文で保存されるため、ルート化デバイスやADBアクセスで容易に読み取り可能
- コンプライアンス: セキュリティベストプラクティスに違反
- 監査: セキュリティ監査で指摘される可能性が高い

### 代替案6: Room + SQLCipher

#### Pros

- 強力な暗号化: データベース全体が暗号化される
- 将来の拡張性: 複雑なデータモデルに対応可能

#### Cons

- 過剰実装: 単純なkey-valueストレージには過剰
- 実装複雑性: データベーススキーマ定義、マイグレーション管理が必要
- パフォーマンスオーバーヘッド: SQLiteのオーバーヘッドが発生
- 依存関係増加: 追加のライブラリが必要

### 代替案7: startActivityForResult()

#### Pros

- レガシー実績: 古いAndroidバージョンで広く使用されてきた
- シンプル: 従来の実装パターンで理解しやすい

#### Cons

- 非推奨（Deprecated）: Android公式により非推奨とされている
- Android 13+対応: 最新のAndroidバージョンで動作保証されない可能性
- ライフサイクル管理: メモリリークのリスクがある
- Jetpack Compose統合: ComposeとのインテグレーションUiがメモリリークのリスクがある

---

## まとめ

本機能は、NIP-55プロトコル、Amethyst Quartz、Clean Architecture + MVVM + Jetpack Compose、Android Keystore + EncryptedSharedPreferences、ActivityResultAPIを選定し、セキュアで保守性の高いログイン機能を実現する。

これらの技術選定は、Android標準のベストプラクティスに準拠し、将来の機能拡張（リレー通信、ブックマーク機能）への基盤を提供する。代替案と比較して、実装時間、セキュリティ、保守性のバランスが最も優れていると判断した。
